# Anjuta internal configuration file

#----------------- WARNING ------------------------------------#
# Any modification in this file without knowing proper internal
# working of Anjuta may lead to instabilites.
#----------------- WARNING ------------------------------------#

# Anjuta uses this file for internal operations,
# therefore this file should never be modified.
# Only Anjuta developers will be tampering with this file. 

# Any modification if needed should be approved by the Anjuta
# developers, so that the source code is also changed (if needed)
# and the changes incorporated in the next release of Anjuta.

##################################################
# Filters to be used in file open/close/save etc #
##################################################
filter.cpp=C/C++ (.c;.cc;.cpp;.cxx;.cs;.h;.hh;.hxx;.hpp;.dlg;.rc;.rc2;.mak)|\
*.c;*.cc;*.cpp;*.cxx;*.cs;*.h;*.hh;*.hxx;*.hpp;*.dlg;*.rc;*.rc2;*.mak;makefile|

############################################
# File patterns defined for all file types #
############################################
file.patterns.c=*.c
file.patterns.cpp=*.cpp;*.cxx;*.cc
file.patterns.header=*.h;*.hh;*.hpp;*.hxx

#########################################
# File icons defined for all file types #
#########################################
icon.$(file.patterns.c)=file_c.png
icon.$(file.patterns.cpp)=file_cpp.png
icon.$(file.patterns.header)=file_h.png

####################################################
# Lexer to be used for corresponding file patterns #
####################################################
lexer.$(file.patterns.c)=cpp
lexer.$(file.patterns.cpp)=cpp
lexer.$(file.patterns.header)=cpp

################################################
# File type corresponding to the file patterns #
################################################
filetype.$(file.patterns.c)=c
filetype.$(file.patterns.cpp)=cpp
filetype.$(file.patterns.header)=header

##################
# Keywords for C #
##################
keywordclass.c=asm auto bool break case char const continue \
do double else enum explicit export extern float for \
goto if inline int long \
register return short signed sizeof static struct switch \
default typedef typename union unsigned \
void volatile wchar_t while TRUE FALSE NULL

keywords.$(file.patterns.c)=$(keywordclass.c)

# keywords2 is for highlighting user defined keywords or function calls or similar
# keywords3 is for doc comment keywords, highlighted in style 17
#CPP doxygen
keywords3.$(file.patterns.cpp)=a addindex addtogroup anchor arg attention \
author b brief bug c class code date def defgroup deprecated dontinclude \
e em endcode endhtmlonly endif endlatexonly endlink endverbatim enum example exception \
f$ f[ f] file fn hideinitializer htmlinclude htmlonly \
if image include ingroup internal invariant interface latexonly li line link \
mainpage name namespace nosubgrouping note overload \
p page par param post pre ref relates remarks return retval \
sa section see showinitializer since skip skipline struct subsection \
test throw todo typedef union until \
var verbatim verbinclude version warning weakgroup $ @ \ & < > # { }

####################
# Keywords for C++ #
####################
keywordclass.cpp=\
catch class const_cast dynamic_cast delete false friend mutable namespace new \
operator private protected public this throw true try virtual using typeid \
template reinterpret_cast static_cast

keywords.$(file.patterns.cpp)=$(keywordclass.cpp) $(keywordclass.c)
keywords.$(file.patterns.header)=$(keywordclass.cpp) $(keywordclass.c)

#######################################
# Characters definition for C and C++ #
#######################################
word.chars.cxx=$(chars.alpha)$(chars.numeric)_#
word.characters.$(file.patterns.cpp)=$(word.chars.cxx)
word.characters.$(file.patterns.c)=$(word.chars.cxx)
word.characters.$(file.patterns.header)=$(word.chars.cxx)

#####################################################################
# Keywords after which auto indention will take place for C and C++ #
#####################################################################
statement.indent.$(file.patterns.cpp)=5 case catch class default do else for if \
private protected public struct try union while switch

statement.indent.$(file.patterns.header)=5 case catch class default do else for if \
private protected public struct try union while switch

statement.indent.$(file.patterns.c)=5 case do else for if struct union while switch

#############################################
# End of statements character for C and C++ #
#############################################
statement.end.$(file.patterns.cpp)=10 ;
statement.end.$(file.patterns.c)=10 ;
statement.end.$(file.patterns.header)=10 ;

#####################################
# Statements lookback for C and C++ #
#####################################
statement.lookback.$(file.patterns.cpp)=20
statement.lookback.$(file.patterns.c)=20
statement.lookback.$(file.patterns.header)=20

#########################################
# Start and end of blocks for C and C++ #
#########################################
block.start.$(file.patterns.cpp)=10 {
block.end.$(file.patterns.cpp)=10 }
block.start.$(file.patterns.c)=10 {
block.end.$(file.patterns.c)=10 }
block.start.$(file.patterns.header)=10 {
block.end.$(file.patterns.header)=10 }

#################################################
# Start and end of comment blocks for C and C++ #
#################################################
comment.block.cpp=//~
#comment.block.at.line.start.cpp=1
comment.stream.start.cpp=/*
comment.stream.end.cpp=*/
comment.box.start.cpp=/*
comment.box.middle.cpp= *
comment.box.end.cpp= */
fold.comment=1
fold.preprocessor=1

##############################################
# Other properties for C and C++ #
##############################################
styling.within.preprocessor=1

##############################################
# Indentation to be maintained by the lexers #
##############################################
#indent.maintain.$(file.patterns.cpp)=1
#indent.maintain.$(file.patterns.c)=1
#indent.maintain.$(file.patterns.h)=1

#autocomplete.cpp.fillups=(

#styling.within.preprocessor=1
preprocessor.symbol.$(file.patterns.cpp)=#
preprocessor.start.$(file.patterns.cpp)=if ifdef ifndef
preprocessor.middle.$(file.patterns.cpp)=else elif
preprocessor.end.$(file.patterns.cpp)=endif

file.has.folds.$(file.patterns.cpp)=1
file.has.tags.$(file.patterns.cpp)=1
file.can.autoformat.$(file.patterns.cpp)=1
file.is.source.$(file.patterns.cpp)=1

file.has.folds.$(file.patterns.c)=1
file.has.tags.$(file.patterns.c)=1
file.can.autoformat.$(file.patterns.c)=1
file.is.source.$(file.patterns.c)=1

file.has.folds.$(file.patterns.header)=1
file.has.tags.$(file.patterns.header)=1
file.can.autoformat.$(file.patterns.header)=1
file.is.source.$(file.patterns.header)=1

apiclass.gnome=$(anjuta.data.directory)/linux-gnome-c.api
api.$(file.patterns.header)=$(apiclass.gnome)
api.$(file.patterns.c)=$(apiclass.gnome)
api.$(file.patterns.cpp)=$(apiclass.gnome)

##############################
# C and C++ style definition #
##############################

# Whitespaces
style.cpp.0=$(style.default.whitespace)
# Comment
style.cpp.1=$(style.default.comment)
# Line Comment
style.cpp.2=$(style.default.comment)
# Doc comment
style.cpp.3=$(style.default.comment)
# Number
style.cpp.4=$(style.default.number)
# Keyword
style.cpp.5=$(style.default.keyword)
# Keyword 2
style.cpp.16=$(style.default.localkeyword)
# Keyword 3
style.cpp.19=$(style.default.syskeyword)
# Double quoted string
style.cpp.6=$(style.default.doublequote)
# Single quoted string
style.cpp.7=$(style.default.singlequote)
# UUIDs (only in IDL)
style.cpp.8=fore:#804080
# Preprocessor
style.cpp.9=$(style.default.preprocessor)
# Operators
style.cpp.10=$(style.default.operator)
# Identifiers
style.cpp.11=$(style.default.identifier)
# End of line where string is not closed
style.cpp.12=$(style.default.unclosedstring)
# Verbatim strings for C#
style.cpp.13=fore:#007F00,back:#E0FFE0,eolfilled
# Braces are only matched in operator style
braces.cpp.style=10

######################################################
# Default Commands for handling different file types #
######################################################

command.compile.file.$(file.patterns.c)=gcc $(anjuta.compiler.flags) -c "$(current.file.name.ext)" -o "$(current.file.name).o"
command.build.file.$(file.patterns.c)=gcc $(anjuta.compiler.flags) "$(current.file.name.ext)" $(anjuta.linker.flags) -o "$(current.file.name)"
command.execute.file.$(file.patterns.c)="$(current.full.filename)" $(anjuta.program.arguments)

command.compile.file.$(file.patterns.cpp)=g++ $(anjuta.compiler.flags) -c "$(current.file.name.ext)" -o "$(current.file.name).o"
command.build.file.$(file.patterns.cpp)=g++ $(anjuta.compiler.flags) "$(current.file.name.ext)" $(anjuta.linker.flags) -o "$(current.file.name)"
command.execute.file.$(file.patterns.cpp)="$(current.full.filename)" $(anjuta.program.arguments)
