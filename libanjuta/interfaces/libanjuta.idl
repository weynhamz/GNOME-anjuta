// -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
//
//  libanjuta interfaces. Generate stubs with anjuta-idl-compiler.pl
// 
//  Copyright (C) 2004 Naba Kumar  <naba@gnome.org>
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Library General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

#include <glib-object.h>

// Implemented by all plugins that can open files
interface IAnjutaFile
{
	/**
	 * ianjuta_file_open:
	 * @obj: Self
	 * @uri: URI to open.
	 * @err: Error propagation and reporting
	 *
	 * The implementor opens the given URI.
	 */
	void open (const gchar *uri);
	
	/**
	 * ianjuta_file_get_uri:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Returns the URI that was opened with ianjuta_file_open().
	 *
	 * Return value: The last URI opened.
	 */
	gchar* get_uri ();
	
	// Implemented by plugins which can also edit the files
	interface IAnjutaFileSavable
	{
		// Signals
		/**
		 * IAnjutaFileSavable::save_point:
		 * @obj: Self
		 * @entered: TRUE if save point is entered, FALSE otherwise.
		 * 
		 * This signal is emitted when the editor enters or leave the save
		 * point. Save point is the point where the contents were saved to
		 * non-volatile memory (e.g. disk). For example, performing undo/redo
		 * will enter or leave the save point in an editor.
		 */
		void ::save_point (gboolean entered);
		
		/**
		 * IAnjutaFileSavable::saved:
		 * @obj: Self
		 * @uri: URI where the content is saved.
		 * 
		 * This signal is emitted when the content is saved.
		 */
		void ::saved (const gchar *uri);
		
		/**
		 * ianjuta_file_savable_save:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 * 
		 * Saves the content to the original URI from which it was loaded.
		 */
		void save ();
		
		/**
		 * ianjuta_file_savable_save_as:
		 * @obj: Self
		 * @uri: URI to save the content.
		 * @err: Error propagation and reporting
		 * 
		 * Saves the content to a different URI.
		 */
		void save_as (const gchar *uri);
		
		/**
		 * ianjuta_file_savable_set_dirty:
		 * @obj: Self
		 * @dirty: 
		 * @err: Error propagation and reporting
		 * 
		 * if @dirty is TRUE, sets dirty for the content. Save point will be
		 * left and the content will be considered not saved. Otherwise,
		 * content will considered saved and save-point will be entered.
		 */
		void set_dirty (gboolean dirty);
		
		/**
		 * ianjuta_file_savable_is_dirty:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 * 
		 * Returns the dirty status of the content.
		 *
		 * Return value: TRUE if dirty, FALSE otherwise.
		 */
		gboolean is_dirty ();
	}
}

// Stream interface
interface IAnjutaStream
{
	#include <stdio.h>
	
	/**
	 * ianjuta_stream_open:
	 * @obj: Self
	 * @stream: Stream to open from.
	 * @err: Error propagation and reporting
	 *
	 * The implementor opens the given stream.
	 */
	void open (FILE* stream);
	
	interface IAnjutaStreamSavable
	{
		/**
		 * ianjuta_stream_save:
		 * @obj: Self
		 * @stream: Stream to save to.
		 * @err: Error propagation and reporting
		 *
		 * The implementor saves the content to the given stream.
		 */
		void save (FILE* stream);
	}
}

// Markables.
// For example, IAnjutaEditor extension - editor capable of marking lines
interface IAnjutaMarkable
{
	enum Error
	{
		INVALID_LOCATION
	}

	enum Marker
	{
		NONE,
		BASIC,
		LIGHT,
		ATTENTIVE,
		INTENSE
	}

	void ::marker_clicked (gboolean double_click, gint location);

	/**
	 * ianjuta_markable_mark:
	 * @obj: Self
	 * @location: Location at which the marker to set.
	 * @marker: Type of marker to be used
	 * @err: Error propagation and reporting
	 *
	 * Marks the specified location with the given marker type. Location is
	 * implementation depenedent. For example, for an editor location means
	 * lines where markers are set.
	 *
	 * Return value: Handle of the location marked. Can be used later to obtain
	 * new location, if it has been moved due to addetions/deletions in the
	 * implementor object.
	 */
	gint mark (gint location, Marker marker);

	/**
	 * ianjuta_markable_location_from_handle:
	 * @obj: Self
	 * @handle: Handle of location.
	 * @err: Error propagation and reporting
	 *
	 * Location where a marker is set could have moved by some operation in
	 * the implementation. To retrieve the correct location where the marker
	 * has moved, pass the handle retured by ianjuta_markable_mark() to this
	 * method.
	 *
	 * Return value: Current location where the marker was set.
	 */
	gint location_from_handle (gint handle);

	void unmark (gint location, Marker marker);
	gboolean is_marker_set (gint location, Marker marker);
	void delete_all_markers (Marker marker);
}

// Implemented by plugins which can build (e.g module manager plugins).
interface IAnjutaBuildable
{
	void build (const gchar *uri);
	void clean (const gchar *uri);
	void install (const gchar *uri);
	void configure (const gchar *uri);
	void generate (const gchar *uri);
}

// Studio profile. Like c++ profile, java profile etc.
interface IAnjutaProfile
{
	#include <libanjuta/e-splash.h>
	
	void load(ESplash *splash);
}

interface IAnjutaHelp
{
	void search (const gchar *query);
}

// Loaders can deterime correct plugin to open a file or stream.  They
// themselves can not load it, but will correctly redirect the request to
// an implementor of IAnjutaFile, IAnjutaFileSavable, IAnjutaStream or
// IAnjutaStreamSavable, depending on the mime-type, meta-type or any other
// requirements.
interface IAnjutaLoader
{
	// Returns all plugins supporting loader interface.
	GSList * find_plugins ();
	
	// Loaders can deterime correct plugin to open a file
	interface IAnjutaFileLoader
	{
		/**
		 * ianjuta_file_loader_load:
		 * @obj: Self
		 * @uri: URI to load
		 * @readonly: Open in readonly mode.
		 * @err: Error propagation and reporting
		 *
		 * Determines a plugin which can open the given file, activates it
		 * opening the file and returns the interface of the plugin activated.
		 * 
		 * Return value: Plugin interface used to load the file.
		 */
		GObject* load (const gchar *uri, gboolean readonly);
		
		/**
		 * ianjuta_loader_peek_interface:
		 * @obj: Self
		 * @uri: Meta file to peek
		 * @err: Error propagation and reporting
		 *
		 * Peeks the file and determines the interface which can load
		 * this file.
		 *
		 * Return value: Plugin interface name that can load the file.
		 */
		gchar* peek_interface (const gchar *uri);
	}
	
	// StreamLoaders can deterime correct plugin to open a stream.
	interface IAnjutaStreamLoader
	{
		#include <stdio.h>
		
		/**
		 * ianjuta_stream_loader_load:
		 * @obj: Self
		 * @stream: Stream to load
		 * @readonly: Open in readonly mode.
		 * @err: Error propagation and reporting
		 *
		 * Determines a plugin which can open the given stream, activates it
		 * opening the stream and returns the interface of the plugin activated.
		 * 
		 * Return value: Plugin interface used to load the stream.
		 */
		GObject* load (FILE *stream, gboolean readonly);
		
		/**
		 * ianjuta_stream_loader_peek_interface:
		 * @obj: Self
		 * @stream: Stream to load
		 * @err: Error propagation and reporting
		 *
		 * Peeks the stream and determines the interface which can load
		 * this stream.
		 *
		 * Return value: Plugin interface name that can load the stream.
		 */
		gchar* peek_interface (FILE *stream);
	}
}

interface IAnjutaEditor
{
	enum Error
	{
		DOESNT_EXIST
	}
	
	// Signals.
	void   ::char_added (gint position, gchar ch);
	void   ::update_ui ();
	
	void   insert (int position, const gchar *text, gint length);
	void   append (const gchar *text, gint length);
	void   goto_line (gint lineno);
	void   goto_position (gint position);
	gchar* get_selection ();
	gchar* get_text (gint start, gint end);
	gchar* get_attributes (gint start, gint end);
	gint   get_position ();

	/**
	 * ianjuta_editor_get_lineno:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Obtains number of the current line in the editor.
	 *
	 * Return value: Line number.
	 */
	gint   get_lineno ();

	gint   get_length ();
	gchar* get_current_word ();

	/**
	 * ianjuta_editor_get_filename:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Allows obtaining of the filename the editor was loaded from.
	 *
	 * Return value: The name of the file. Not to be freed by caller.
	 */
	const gchar* get_filename ();
}

interface IAnjutaDocumentManager
{
	#include "ianjuta-editor.h"
	
	enum Error
	{
		DOESNT_EXIST
	}

	const gchar * get_full_filename (const gchar *file);
	IAnjutaEditor* find_editor_with_path (const gchar *file_path);
	void goto_file_line (const gchar *file, gint lineno);
	void goto_file_line_mark (const gchar *file, gint lineno, gboolean mark);
	IAnjutaEditor* get_current_editor ();
	void set_current_editor (IAnjutaEditor *editor);
	GList* get_editors ();

	// New editor buffer
	IAnjutaEditor* add_buffer (const gchar *name, const gchar* content);
}

interface IAnjutaMessageView
{
	enum Type
	{
		TYPE_NORMAL,
		TYPE_INFO,
		TYPE_WARNING,
		TYPE_ERROR
	}
	
	// Signals
	void ::message_clicked (const gchar *message);
	void ::buffer_flushed (const gchar *line);
	
	/* Buffer methods */
	void buffer_append (const gchar *text);
	void append (Type type, const gchar *summary, const gchar *details);
	void clear ();
	void select_next ();
	void select_previous ();
	const gchar* get_current_message ();
	GList* get_all_messages ();
}

interface IAnjutaMessageManager
{
	#include "ianjuta-message-view.h"
	
	enum Error
	{
		DOESNT_EXIST
	}
	/**
	 * ianjuta_message_manager_add_view:
	 * @obj: Self
	 * @name: Name/Title of the new view
	 * @icon: Path to an icon or ""
	 * @err: Error propagation and reporting
	 *
	 * Adds a new view to the message-manager
	 *
	 * Return value: The new message-view
	 */
	IAnjutaMessageView* add_view (const gchar *name, const gchar *icon);
	
	/**
	 * ianjuta_message_manager_remove_view:
	 * @obj: Self
	 * @view: The view to remove
	 * @err: Error propagation and reporting
	 *
	 * Remove view from the message-manager. The view
	 * will become invalid.
	 *
	 * Return value: The new message-view
	 */
	void remove_view (IAnjutaMessageView *view);
	
	/**
	 * ianjuta_message_manager_get_current_view:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get the view with is currently on top of 
	 * the notebook or NULL if the message-manager is empty.
	 *
	 * Return value: Current view; #IAnjutaMessageView object.
	 * NULL, if there is no views.
	 */
	IAnjutaMessageView* get_current_view ();
	
	/**
	 * ianjuta_message_manager_get_view_by_name:
	 * @obj: Self
	 * @name: Name/Title of the view
	 * @err: Error propagation and reporting
	 *
	 * Get the view with the given name or NULL if
	 * it does not exist.
	 *
	 * Return value: The message-view or NULL
	 */
	IAnjutaMessageView* get_view_by_name (const gchar *name);
	
	/**
	 * ianjuta_message_manager_get_all_views:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get all message-views
	 *
	 * Return value: A GList* of all views. You must not
	 * manipulate the list.
	 */
	GList* get_all_views ();
	
	/**
	 * ianjuta_message_manager_set_current_view:
	 * @obj: Self
	 * @view: A message view
	 * @err: Error propagation and reporting
	 *
	 * Set view to be on top of the notebook.
	 *
	 */
	void set_current_view (IAnjutaMessageView *view);
	
	/**
	 * ianjuta_message_manager_set_view_title:
	 * @obj: Self
	 * @view: A message view
	 * @title: Sets the title of view.
	 * @err: Error propagation and reporting
	 *
	 * Sets the title of view.
	 *
	 */
	void set_view_title (IAnjutaMessageView *view, const gchar *title);
}

interface IAnjutaFileManager
{
	void ::section_changed (const gchar *uri);
	
	void set_root (const gchar *root_uri);
	gchar* get_selected ();
	void set_selected (const gchar *uri);
}

interface IAnjutaTerminal
{
	#include <sys/types.h>
	pid_t execute_command (const gchar *command);
}

interface IAnjutaProjectManager
{
	enum ElementType
	{
		UNKNOWN,
		SOURCE,
		TARGET,
		GROUP
	}
	
	enum TargetType
	{
		TARGET_UNKNOWN,
		TARGET_SHAREDLIB,
		TARGET_STATICLIB,
		TARGET_EXECUTABLE
	}
	
	// Signals
	void ::element_added (const gchar *element_uri);
	void ::element_removed (const gchar *element_uri);
	void ::element_selected (const gchar *element_uri);
	
	// Methods
	ElementType get_element_type (const gchar *element_uri);
	GList* get_elements (ElementType element_type);
	
	TargetType get_target_type (const gchar *target_uri);
	GList* get_targets (TargetType target_type);
	
	gchar* get_parent (const gchar *element_uri);
	GList* get_children (const gchar *element_uri);
	gchar* get_selected ();
	
	gboolean add_source (const gchar *source_uri, const gchar *target_uri);
	gboolean add_target (const gchar *target_uri);
	gboolean add_group (const gchar *group_uri);
}

interface IAnjutaTodo
{
	void load(gchar *uri);
}

interface IAnjutaWizard
{
	void activate();
}

interface IAnjutaDebuggerManager
{
	gboolean is_active ();
	gboolean is_busy ();
	
	void start (const gchar *prog_uri);
	gboolean stop ();
}

interface IAnjutaDebugger
{
	// Sinals
	void ::busy (gboolean busy_state);
	
	gboolean is_busy ();

	void load (const gchar *prog_uri);

	void run_continue ();
	void step_in ();
	void step_over ();
	void step_out ();
	void run_to_position (const gchar *uri, gint line);
	
	void breakpoint_toggle (const gchar *uri, gint line);
	void breakpoint_set (const gchar *uri, gint line);
	void breakpoint_delete (const gchar *uri, gint line);
}

interface IAnjutaVcs
{
	/**
	 * ianjuta_vcs_add:
	 * @filename: String with the filename
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Add filename to the cvs repositry.
	 */
	void add(const gchar* filename);
	
	/**
	 * ianjuta_cvs_remove:
	 * @filename: String with the filename
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Remove filename to the cvs repositry. Note that the file
	 * is not removed physicly. This function will fail if the file
	 * still exists on disc.
	 */
	void remove(const gchar* filename);
	
	/**
	 * ianjuta_vcs_update:
	 * @filename: String with the filename
	 * @recurse: TRUE to recurse into subdirectories
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Update filename with the cvs repositry.
	 */
	void update(const gchar* filename, gboolean recurse);
	
	/**
	 * ianjuta_vcs_commit:
	 * @filename: String with the filename
	 * @log: The log message for the commit or ""
	 * @recurse: TRUE to recurse into subdirectories
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Commit changes in filename to the cvs repositry.
	 */
	void commit(const gchar* filename, const gchar* log, gboolean recurse);	
}

interface IAnjutaMacro
{
	/**
	 * ianjuta_macro_insert:
	 * @key: Key of the macro
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Insert Macro to editor
	 */
	void insert(const gchar* key);
}
