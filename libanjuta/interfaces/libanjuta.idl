// -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
// -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
//
//  libanjuta interfaces. Generate stubs with anjuta-idl-compiler.pl
//
//  Copyright (C) 2004 Naba Kumar  <naba@gnome.org>
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Library General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

#include <glib-object.h>

/**
 * SECTION:ianjuta-file
 * @title: IAnjutaFile
 * @short_description: Implemented by plugins that can open files.
 * @see_also: #IAnjutaFileSavable
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-file.h
 *
 * Any plugin that can open files should implemented this interface. Along
 * with the 'File Loader::SupportedMimeTypes' property of the plugin in
 * .plugin file, it will be used by the loader to open files of that type.
 */
interface IAnjutaFile
{
	#include <gio/gio.h>
	/**
	 * ianjuta_file_open:
	 * @obj: Self
	 * @file: file to open.
	 * @err: Error propagation and reporting
	 *
	 * The implementor opens the given file.
	 */
	void open (GFile* file);

	/**
	 * IAnjutaFileSavable::saved:
	 * @obj: Self
     *
	 * This signal is emitted when the content is loaded completely.
	 */
	void ::opened ();

	/**
	 * ianjuta_file_get_file:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Returns the file that was opened with ianjuta_file_open().
	 *
	 * Return value: (transfer full): The last file opened.
	 */
	GFile* get_file ();

	/**
	 * SECTION:ianjuta-file-savable
	 * @title: IAnjutaFileSavable
	 * @short_description: Implemented by plugins that can save files.
	 * @see_also: #IAnjutaFile
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-file-savable.h
	 *
	 * Plugins implementing #IAnjutaFile inteface that can also save files
	 * should also implement this interface.
	 */
	interface IAnjutaFileSavable
	{
		/**
		 * IAnjutaFileSavable::update_save_ui:
		 * @obj: Self
		 *
		 * This signal is emitted when the state of the file has
		 * changed. It could be that the user writes in it
		 * and the file becomes dirty or the opposite: after using
		 * undo, the file is back to its saved content. It is triggered
		 * if the file becomes read-only or give a conflict too.
		 */
		void ::update_save_ui ();

		/**
		 * IAnjutaFileSavable::saved:
		 * @obj: Self
		 * @file: file where the content is saved or NULL if save failed
		 *
		 * This signal is emitted when the content is saved.
		 */
		void ::saved (GFile* file);

		/**
		 * ianjuta_file_savable_save:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Saves the content to the original file from which it was loaded.
		 * The signal saved is always emitted even if the save fails.
		 */
		void save ();

		/**
		 * ianjuta_file_savable_save_as:
		 * @obj: Self
		 * @file: File to save the content.
		 * @err: Error propagation and reporting
		 *
		 * Saves the content to a different File.
		 * The signal saved is always emitted even if the save fails.
		 */
		void save_as (GFile* file);

		/**
		 * ianjuta_file_savable_set_dirty:
		 * @obj: Self
		 * @dirty: Whether the file was edited or not
		 * @err: Error propagation and reporting
		 *
		 * if @dirty is TRUE, sets dirty for the content. Save point will be
		 * left and the content will be considered not saved. Otherwise,
		 * content will considered saved and save-point will be entered.
		 */
		void set_dirty (gboolean dirty);

		/**
		 * ianjuta_file_savable_is_dirty:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Returns the dirty status of the content.
		 *
		 * Return value: TRUE if dirty, FALSE otherwise.
		 */
		gboolean is_dirty ();

		/**
		 * ianjuta_file_savable_is_read_only:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Return is the file is read-only
		 *
		 * Return value: TRUE if read-only, FALSE otherwise.
		 */
		gboolean is_read_only ();

		/**
		 * ianjuta_file_savable_is_conflict:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Return is the file is in conflict. It means the file
		 * has been modified externally and the user needs to
		 * tell which version he wants to use.
		 *
		 * Return value: TRUE if conflict, FALSE otherwise.
		 */
		gboolean is_conflict ();
	}
}

/**
 * SECTION:ianjuta-stream
 * @title: IAnjutaStream
 * @short_description: Implemented by plugins that can open file streams
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-stream.h
 *
 */
interface IAnjutaStream
{
	#include <stdio.h>

	/**
	 * ianjuta_stream_open:
	 * @obj: Self
	 * @stream: Stream to open from.
	 * @err: Error propagation and reporting
	 *
	 * The implementor opens the given stream.
	 */
	void open (FILE* stream);

	/**
	 * SECTION:ianjuta-stream-savable
	 * @title: IAnjutaStreamSavable
	 * @short_description: Implemented by plugins that can save file streams
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-stream-savable.h
	 *
	 */
	interface IAnjutaStreamSavable
	{
		/**
		 * ianjuta_stream_save:
		 * @obj: Self
		 * @stream: Stream to save to.
		 * @err: Error propagation and reporting
		 *
		 * The implementor saves the content to the given stream.
		 */
		void save (FILE* stream);
	}
}

/**
 * SECTION:ianjuta-markable
 * @title: IAnjutaMarkable
 * @short_description: Implemented by editors (or views) with markers support
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-markable.h
 *
 */
interface IAnjutaMarkable
{
	enum Error
	{
		INVALID_LOCATION
	}

  /**
   * IAnjutaMarkableMarker:
   * @IANJUTA_MARKABLE_LINEMARKER: Mark a particular line
   * @IANJUTA_MARKABLE_BOOKMARK: A bookmark
   * @IANJUTA_MARKABLE_MESSAGE: An (error) message
   * @IANJUTA_MARKABLE_BREAKPOINT_DISABLED: a disabled breakpoint
   * @IANJUTA_MARKABLE_BREAKPOINT_ENABLED: a enabled breakpoint
   * @IANJUTA_MARKABLE_PROGRAM_COUNTER: Marks the program counter position
   *
   * This enumeration is used to specify the pixmap used for the marker
   */
	enum Marker
	{
		LINEMARKER,
		BOOKMARK,
		MESSAGE,
		BREAKPOINT_DISABLED,
		BREAKPOINT_ENABLED,
		PROGRAM_COUNTER
	}

	/**
	 * IAnjutaMarkable::marker-clicked:
	 * @obj: Self
	 * @double_click: whether the marker was double clicked
	 * @location: location of the clicked marker
	 *
	 * The signal is emitted when the user clicks on a marker
	 */
	void ::marker_clicked (gboolean double_click, gint location);

	/**
	 * ianjuta_markable_mark:
	 * @obj: Self
	 * @location: Location at which the marker to set.
	 * @marker: Type of marker to be used
	 * @tooltip: (allow-none): optional tooltip displayed with the marker
	 * @err: Error propagation and reporting
	 *
	 * Marks the specified location with the given marker type. Location is
	 * implementation depenedent. For example, for an editor location means
	 * lines where markers are set.
	 *
	 * Return value: Handle of the location marked. Can be used later to obtain
	 * new location, if it has been moved due to addetions/deletions in the
	 * implementor object.
	 */
	gint mark (gint location, Marker marker, const gchar* tooltip);

	/**
	 * ianjuta_markable_location_from_handle:
	 * @obj: Self
	 * @handle: Handle of location.
	 * @err: Error propagation and reporting
	 *
	 * Location where a marker is set could have moved by some operation in
	 * the implementation. To retrieve the correct location where the marker
	 * has moved, pass the handle retured by ianjuta_markable_mark() to this
	 * method.
	 *
	 * Return value: Current location where the marker was set.
	 */
	gint location_from_handle (gint handle);

	/**
	* ianjuta_markable_unmark:
	* @obj: Self
	* @location: Location where the marker is set.
	* @marker: The marker to unset.
	* @err: Error propagation and reporting
	*
	* Clears the @marker at given @location.
	*/
	void unmark (gint location, Marker marker);

	/**
	* ianjuta_markable_is_marker_set:
	* @obj: Self
	* @location: Location to check.
	* @marker: Marker to check.
	* @err: Error propagation and reporting
	*
	* Check if the @marker is set at the given @location.
	*
	* Returns: TRUE if the marker is set at the location, other false.
	*/
	gboolean is_marker_set (gint location, Marker marker);

	/**
	* ianjuta_markable_delete_all_markers:
	* @obj: Self
	* @marker: Marker to delete.
	* @err: Error propagation and reporting
	*
	* Delete the @marker from all locations.
	*/
	void delete_all_markers (Marker marker);
}

/**
 * SECTION:ianjuta-indicable
 * @title: IAnjutaIndicable
 * @short_description: Implemented by indicate that indicate a range
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-indicable.h
 *
 */
interface IAnjutaIndicable
{
	#include <libanjuta/interfaces/ianjuta-iterable.h>

	/**
   * IAnjutaIndicableIndicator:
   * @IANJUTA_INDICABLE_NONE: No indicator
   * @IANJUTA_INDICABLE_IMPORTANT: Important indicator
   * @IANJUTA_INDICABLE_WARNING: Warning indicator
   * @IANJUTA_INDICABLE_CRITICAL: Critical indicator
   *
   * This enumeration is used to specify the appearance of the indicator
   */
	enum Indicator
	{
		NONE,
		IMPORTANT,
		WARNING,
		CRITICAL
	}

 /**
	* ianjuta_indicable_set:
	* @obj: Self
	* @begin_location: Location where the indication should start
	* @end_location: Location where the indication should end
	* @indicator: the indicator to use
	* @err: Error propagation and reporting
	*
	* Set an indicator
	*
	*/
	void set (IAnjutaIterable *begin_location, IAnjutaIterable *end_location, Indicator indicator);

 /**
	* ianjuta_indicable_clear:
	* @obj: Self
	* @err: Error propagation and reporting
	*
	* Clear all indicators
	*
	*/
	void clear ();
}

/**
 * SECTION:ianjuta-iterable
 * @title: IAnjutaIterable
 * @short_description: Implemented by objects that can iterate
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-iterable.h
 *
 */
interface IAnjutaIterable
{
	/**
	* ianjuta_iterable_first:
	* @obj: Self
	* @err: Error propagation and reporting
	*
	* Set iter to first element position. Returns FALSE if
	* there is no element in the iterable (hence does not have first).
	* The iter points to the first valid item.
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean first ();

	/**
	* ianjuta_iterable_next:
	* @obj: Self
	* @err: Error propagation and reporting
	*
	* Set the iter position to next element position. Iter can go until one
	* item past the last item and lands in end-iter. end-iter does not point
	* to any valid item and signifies end of the list. Returns FALSE if iter
	* was already at end-iter (iter can not go past it) and remains pointed
	* to the end-iter.
	*
	* Returns: TRUE if sucessful, otherwise FALSE if already at end-iter.
	*/
	gboolean next ();

	/**
	* ianjuta_iterable_previous:
	* @obj: Self
	* @err: Error propagation and reporting
	*
	* Set the iter position to previous element position. Returns FALSE if
	* there is no previous element and the iter remains pointed to the first
	* element.
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean previous ();

	/**
	* ianjuta_iterable_last:
	* @obj: Self
	* @err: Error propagation and reporting
	*
	* Set iter position to end-iter (one past last element) position.
	* Returns FALSE if there is no element in the iterable (already
	* at end-iter).
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean last ();

	/**
	* ianjuta_iterable_foreach:
	* @obj: Self
	* @callback: Callback to call for each element.
	* @user_data: user data that is passed back to the callback.
	* @err: Error propagation and reporting
	*
	* Call callback for each element in the list. Call back is passed the
	* same iter, but with different position set (from first to last). This
	* method does not affect current position. i.e. current position is
	* restored at the end of this method.
	*/
	void foreach (GFunc callback, gpointer user_data);

	/**
	* ianjuta_iterable_set_position:
	* @obj: Self
	* @position: New position for the iter.
	* @err: Error propagation and reporting
	*
	* Sets the current position of the iter to @position. The given @position
	* must be from 0 to length - 1 (#ianjuta_iter_get_length()) to point to
	* a valid element. Passing @position < 0 will set it to end-iter. It
	* returns TRUE for the above cases. FLASE will be returned, if
	* out-of-range @position is passed (@position > length - 1) and iter is
	* set to end-iter.
	*
	* Returns: TRUE if successfully set (i.e. @position is within the range or
	* end-iter). otherwise returns FALSE (i.e. @position is out of data range).
	*/
	gboolean set_position (gint position);

	/**
	* ianjuta_iterable_get_position:
	* @obj: Self
	* @err: Error propagation and reporting
	*
	* Index of the current iter in the iterable. It will be
	* from 0 to length - 1 (ianjuta_iter_get_length()) if iter is pointed
	* at valid element. It will return -1 if iter is pointed at end-iter.
	*
	* Returns: integer index, or -1 for end-iter.
	*/
	gint get_position ();

	/**
	* ianjuta_iterable_get_length:
	* @obj: Self
	* @err: Error propagation and reporting
	*
	* Length of the iterable (number of elements indexable by it).
	*
	* Returns: total length of the list.
	*/
	gint get_length ();

	/**
	 * ianjuta_iterable_clone:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Clones the iterable. The returned iterable object must be unreffed
	 * when done.
	 *
	 * Returns: (transfer full): A new instance of this iterable pointing at the same location.
	 */
	IAnjutaIterable *clone ();

	/**
	* ianjuta_iterable_assign:
	* @obj: Self
	* @src_iter: Source iter from which to copy the assignment.
	* @err: Error propagation and reporting
	*
	* Assigns the iter position from @src_iter.
	*
	*/
	void assign (IAnjutaIterable *src_iter);

	/**
	* ianjuta_iterable_compare:
	* @obj: Self
	* @iter2: Second iter to compare.
	* @err: Error propagation and reporting
	*
	* Compares the position of @iter2 with this @obj. Returns -1
	* value if this @obj is smaller than @iter2. Returns +1 value
	* if this @obj is larger than @iter2. And returns 0 if both are equal.
	* If you want difference of the iter positions, use
	* #ianjuta_iterable_diff(). This method is meant for fast comparision.
	*
	* Returns: 0 if equal, -1 if @obj is smaller than @iter2
	* or +1 if @obj is larger than @iter2.
	*
	*/
	gint compare (IAnjutaIterable *iter2);

	/**
	* ianjuta_iterable_diff:
	* @obj: Self
	* @iter2: Second iter to differenciate.
	* @err: Error propagation and reporting
	*
	* Compares the position of @iter2 with this @obj and returns difference
	* in position of the two (@obj - @iter2).
	*
	* Returns: The position difference of @obj - @iter2
	*
	*/
	gint diff (IAnjutaIterable *iter2);

	/**
	 * SECTION:ianjuta-iterable-tree
	 * @title: IAnjutaIterableTree
	 * @short_description: Implemented by tree objects that can iterate
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-iterable-tree.h
	 *
	 */
	interface IAnjutaIterableTree
	{

		/**
		* ianjuta_iterable_tree_parent:
		* @obj: Self
		* @err: Error propagation and reporting
		*
		* Set iter position to parent of curernt iter. If there is no parent,
		* returns FALSE (current iter position is not changed)
		*
		* Returns: TRUE if sucessful, otherwise FALSE.
		*/
		gboolean parent ();

		/**
		* ianjuta_iterable_tree_children:
		* @obj: Self
		* @err: Error propagation and reporting
		*
		* Iter position set to first child of current iter. If there is no
		* children, return NULL (iter position is not changed).
		*
		* Returns: TRUE if sucessful, otherwise FALSE.
		*/
		gboolean children ();

		/**
		* ianjuta_iterable_tree_has_children:
		* @obj: Self
		* @err: Error propagation and reporting
		*
		* Returns true if current iter has children
		*
		* Returns: TRUE if there are children, otherwise FALSE.
		*/
		gboolean has_children ();

		/**
		* ianjuta_iterable_tree_foreach_post:
		* @obj: Self
		* @callback: Callback to call for each element.
		* @user_data: User data to pass back to callback.
		* @err: Error propagation and reporting
		*
		* Call callback for each element in post order.
		*/
		void foreach_post (GFunc callback, gpointer user_data);

		/**
		* ianjuta_iterable_tree_foreach_pre:
		* @obj: Self
		* @callback: Callback to call for each element.
		* @user_data: User data to pass back to callback.
		* @err: Error propagation and reporting
		*
		* Call callback for each element in pre order.
		*/
		void foreach_pre (GFunc callback, gpointer user_data);
	}
}

/**
 * SECTION:ianjuta-builder
 * @title: IAnjutaBuilder
 * @short_description: Implemented by plugins that can build
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-builder.h
 *
 */
interface IAnjutaBuilder
{
  /**
   * IAnjutaBuilderError:
   * @IANJUTA_BUILDER_SUCCEED: Build succeeded
   * @IANJUTA_BUILDER_FAILED: Build failed
   * @IANJUTA_BUILDER_CANCELED: Build was canceld
   * @IANJUTA_BUILDER_ABORTED: Build aborted
   * @IANJUTA_BUILDER_INTERRUPTED: Build interruped
   * @IANJUTA_BUILDER_TERMINATED: Build interruped
   * @IANJUTA_BUILDER_UNKNOWN_TARGET: The specified target is unknown
   * @IANJUTA_BUILDER_UNKNOWN_ERROR: Unknown Error
   * @IANJUTA_BUILDER_OTHER_ERROR: Other Error (no unknown ;-))
   *
   * Possible build errors
   */
	enum Error
	{
		SUCCEED           =  0,
		FAILED,
		CANCELED	= 256,
		ABORTED,
		INTERRUPTED,
		TERMINATED,
		UNKNOWN_TARGET,
		UNKNOWN_ERROR,
		OTHER_ERROR
	}

	typedef gpointer Handle;

	typedef void (*Callback) (GObject *sender, IAnjutaBuilderHandle command, GError* err, gpointer user_data);

	/**
	* IANJUTA_BUILDER_ROOT_URI
	*
	* Build directory uri. It is the same than the project_root_uri for
	* in source build.
	*/
	#define ROOT_URI		"build_root_uri"

	/**
	* IANJUTA_BUILDER_CONFIGURATION_DEBUG
	*
	* Name of debugging configutation.
	*/
	#define CONFIGURATION_DEBUG	"Debug"

	/**
	* IANJUTA_BUILDER_CONFIGURATION_OPTIMIZED
	*
	* Name of optimized configutation.
	*/
	#define CONFIGURATION_OPTIMIZED	"Optimized"

	/**
	* IANJUTA_BUILDER_CONFIGURATION_PROFILING
	*
	* Name of profiling configutation.
	*/
	#define CONFIGURATION_PROFILING	"Profiling"

	/**
	* ianjuta_builder_is_built:
	* @obj: Self
	* @uri: target uri
	* @callback: callback called when command is finished
	* @user_data: data passed to the callback
	* @err: Error propagation and reporting.
	*
	* Check if the corresponding target is up to date or not. This
	* command doesn't display anything. If this command cannot be
	* implemented, it is possible to return always TRUE.
	* When the command is finished, the callback function is called
	* if defined.
	*
	* Returns: non null command handle if succeed
	*/
	Handle is_built (const gchar *uri, Callback callback, gpointer user_data);

	/**
	* ianjuta_builder_build:
	* @obj: Self
	* @uri: target uri
	* @callback: callback called when command is finished
	* @user_data: data passed to the callback
	* @err: Error propagation and reporting.
	*
	* Build the specified target.
	* When the command if finished, the callback function is called
	* if defined.
	*
	* Returns: non null command handle if succeed
	*/
	Handle build (const gchar *uri, Callback callback, gpointer user_data);

	/**
	* ianjuta_builder_cancel:
	* @obj: Self
	* @handle: handle of the command to cancel
	* @err: Error propagation and reporting.
	*
	* Cancel specified command. The callback function will not
	* be called.
	*
	*/
	void cancel (Handle handle);

	/**
	 * ianjuta_builder_list_configuration:
	 * @obj: Self
	 * @err: Error propagation and reporting.
	 *
	 * List all defined configuration. These names returned are
	 * the internal non localized names for the following
	 * predefined configuration: Debug, Profiling, Optimized.
	 * The default configuration has no name and is not returned.
	 *
	 * Returns: (element-type utf8) (transfer container): a list configuration name. The names are owned
	 * by the plugin, so only the list has to be free using
	 * g_list_free.
	 */
	List<const gchar*> list_configuration();

	/**
	* ianjuta_builder_get_uri_configuration:
	* @obj: Self
	* @uri: target uri
	* @err: Error propagation and reporting.
	*
	* Get the configuration corresponding to the target uri.
	*
	* Returns: The configuration name or NULL if the corresponding
	* configuration cannot be found.
	*/
	const gchar* get_uri_configuration(const gchar *uri);
}

/**
 * SECTION:ianjuta-environment
 * @title: IAnjutaEnvironment
 * @short_description: Implemented by plugins doing cross compilation
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-environment.h
 *
 */
interface IAnjutaEnvironment
{
	/**
   * IAnjutaEnvironmentError:
   * @IANJUTA_BUILDER_CONFIG: Configuration of the environment is wrong
   * @IANJUTA_BUILDER_OTHER_ERROR: Other Error (no unknown ;-))
   *
   * Possible build errors
   */
	enum Error
	{
		CONFIG,
		OTHER_ERROR
	}

	/**
	* ianjuta_environment_override:
	* @obj: Self
	* @dirp: a pointer on the working directory
	* @argvp: a pointer on a NULL terminated string array
	*     containing the command name in argv[0] and all
	*    its argument
	* @envp: a pointer on a NULL terminated string array
	*    containing all additional environment variable
	*    used by the command
	* @err: Error propagation and reporting.
	*
	* Override a command to work in another build environment
	*
	* Returns: FALSE if there is an error.
	*/
	gboolean override (gchar **dirp, gchar ***argvp, gchar ***envp);

	/**
	* ianjuta_environment_get_real_directory:
	* @obj: Self
	* @dir: A directory path in the environment
	* @err: Error propagation and reporting.
	*
	* Convert a directory in the environment to a directory outside.
	* It is useful when the environment use chroot. Take care that
	* the input directory string is freed using g_free but and you need to
	* free the output string when not needed.
	*
	* Returns: The directory path outside the environment
	*/
	gchar* get_real_directory (gchar *dir);
}

/**
 * SECTION:ianjuta-buildable
 * @title: IAnjutaBuildable
 * @short_description: Implemented by plugins that can build. This interface
 * will be replaced by #IAnjutaBuilder (for build functions) and
 * #IAnjutaEnvironment for ianjuta_buildable_set_command,
 * ianjuta_buildable_reset_command and ianjuta_buildable_get_command.
 * @see_also:
 * @stability: Obsolete
 * @include: libanjuta/interfaces/ianjuta-buildable.h
 *
 */
interface IAnjutaBuildable
{

	/**
   * IAnjutaBuildableCommand:
   * @IANJUTA_BUILDABLE_COMMAND_COMPILE: Compile source
   * @IANJUTA_BUILDABLE_COMMAND_BUILD: Build file (normally using make)
   * @IANJUTA_BUILDABLE_COMMAND_BUILD_TARBALL: make dist
   * @IANJUTA_BUILDABLE_COMMAND_INSTALL: make install
   * @IANJUTA_BUILDABLE_COMMAND_CONFIGURE: ./configure
   * @IANJUTA_BUILDABLE_COMMAND_GENERATE: ./autogen.sh
   * @IANJUTA_BUILDABLE_COMMAND_CLEAN: make clean
   * @IANJUTA_BUILDABLE_COMMAND_EXECUTE: ./hello
   * @IANJUTA_BUILDABLE_COMMAND_IS_BUILT: check whether object files are up-to-date
   * @IANJUTA_BUILDABLE_COMMAND_DISTCLEAN: make distclean
   * @IANJUTA_BUILDABLE_COMMAND_CHECK: make check
   * @IANJUTA_BUILDABLE_N_COMMANDS: size of enum
   *
   * The enumeration is used to speficy the disered build operation
   */
	enum Command
	{
		COMMAND_COMPILE,
		COMMAND_BUILD,
		COMMAND_BUILD_TARBALL,
		COMMAND_INSTALL,
		COMMAND_CONFIGURE,
		COMMAND_GENERATE,
		COMMAND_CLEAN,
		COMMAND_EXECUTE,
		COMMAND_IS_BUILT,
		COMMAND_AUTORECONF,
		COMMAND_DISTCLEAN,
		COMMAND_CHECK,
		N_COMMANDS
	}

	/**
	* ianjuta_buildable_set_command:
	* @obj: Self
	* @command_id: Command to override.
	* @command: Build command to override.
	* @err: Error propagation and reporting.
	*
	* Overrides the default command for the given command.
	*/
	void set_command (Command command_id, const gchar *command);

	/**
	* ianjuta_buildable_get_command:
	* @obj: Self
	* @command_id: Command to get override.
	* @err: Error propagation and reporting.
	*
	* Retrieves the currently set command override.
	*
	* Returns: The overridden command. NULL if no override set.
	*/
	const gchar* get_command (Command command_id);

	/**
	* ianjuta_buildable_reset_commands:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Resets the command overrides to defaults.
	*/
	void reset_commands ();

	/**
	* ianjuta_buildable_build:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	*
	* fixme
	*/
	void build (const gchar *uri);

	/**
	* ianjuta_buildable_clean:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	*
	* fixme
	*/
	void clean (const gchar *uri);

	/**
	* ianjuta_buildable_install:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	*
	* fixme
	*/
	void install (const gchar *uri);

	/**
	* ianjuta_buildable_configure:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	*
	* fixme
	*/
	void configure (const gchar *uri);

	/**
	* ianjuta_buildable_generate:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	*
	* fixme
	*/
	void generate (const gchar *uri);

	/**
	* ianjuta_buildable_execute:
	* @obj: Self
	* @uri: fixme
	* @err: Error propagation and reporting.
	*
	* fixme
	*/
	void execute (const gchar *uri);
}

/**
 * SECTION:ianjuta-help
 * @title: IAnjutaHelp
 * @short_description: Implemented by plugins that can provide help support
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-help.h
 *
 */
interface IAnjutaHelp
{

	/**
	* ianjuta_help_search:
	* @obj: Self
	* @query: string to search in the help
	* @err: Error propagation and reporting
	*
	* Search for string @query in the help and display the result
	*/
	void search (const gchar *query);
}

/**
 * SECTION:ianjuta-loader
 * @title: IAnjutaLoader
 * @short_description: Interface to load file or stream
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-loader.h
 *
 * Loaders can deterime correct plugin to open a file or stream.  They
 * themselves can not load it, but will correctly redirect the request to
 * an implementor of IAnjutaFile, IAnjutaFileSavable, IAnjutaStream or
 * IAnjutaStreamSavable, depending on the mime-type, meta-type or any other
 * requirements.
 */
interface IAnjutaLoader
{
	#include <libanjuta/anjuta-plugin.h>
	/**
	 * ianjuta_loader_find_plugins:
	 * @obj: Self
	 * @err: Error propagation and reporting.
	 *
	 * Returns: (element-type AnjutaPlugin): all plugins supporting loader interface.
	 */
	List<AnjutaPlugin*> find_plugins ();

	/**
	 * SECTION:ianjuta-file-loader
	 * @title: IAnjutaFileLoader
	 * @short_description: Loader to load files
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-file-loader.h
	 *
	 * Loaders can deterime correct plugin to open a file.
	 */
	interface IAnjutaFileLoader
	{
		#include <gio/gio.h>
		/**
		 * ianjuta_file_loader_load:
		 * @obj: Self
		 * @file: File to load
		 * @readonly: Open in readonly mode.
		 * @err: Error propagation and reporting
		 *
		 * Determines a plugin which can open the given file, activates it
		 * opening the file and returns the interface of the plugin activated.
		 *
		 * Return value: Plugin interface used to load the file.
		 */
		GObject* load (GFile* file, gboolean readonly);

		/**
		 * ianjuta_loader_peek_interface:
		 * @obj: Self
		 * @file: Meta file to peek
		 * @err: Error propagation and reporting
		 *
		 * Peeks the file and determines the interface which can load
		 * this file.
		 *
		 * Return value: Plugin interface name that can load the file.
		 */
		gchar* peek_interface (GFile* file);
	}

	/**
	 * SECTION:ianjuta-stream-loader
	 * @title: IAnjutaStreamLoader
	 * @short_description: Loader to load streams
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-stream-loader.h
	 *
	 * StreamLoaders can deterime correct plugin to open a stream.
	 */
	interface IAnjutaStreamLoader
	{
		#include <stdio.h>

		/**
		 * ianjuta_stream_loader_load:
		 * @obj: Self
		 * @stream: Stream to load
		 * @readonly: Open in readonly mode.
		 * @err: Error propagation and reporting
		 *
		 * Determines a plugin which can open the given stream, activates it
		 * opening the stream and returns the interface of the plugin activated.
		 *
		 * Return value: Plugin interface used to load the stream.
		 */
		GObject* load (FILE *stream, gboolean readonly);

		/**
		 * ianjuta_stream_loader_peek_interface:
		 * @obj: Self
		 * @stream: Stream to load
		 * @err: Error propagation and reporting
		 *
		 * Peeks the stream and determines the interface which can load
		 * this stream.
		 *
		 * Return value: Plugin interface name that can load the stream.
		 */
		gchar* peek_interface (FILE *stream);
	}
}

/**
 * SECTION:ianjuta-document
 * @title: IAnjutaDocument
 * @short_description: Interface for all kind of editable resources that
 * will be managed by IAnjutaDocumentManager
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-document.h
 *
 */
interface IAnjutaDocument
{
	/**
	 * IAnjutaDocument::update-ui:
	 * @obj: Self
	 *
	 * This signal is emitted when the document assumes the UI must be updated
	 * because some internal state of the document has changed. For example, if
	 * current line position is changed, it needs to be reflected to the UI.
	 */
	void   ::update_ui ();

	/**
	 * ianjuta_document_get_filename:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Allows obtaining of the filename the editor was loaded from.
	 *
	 * Return value: The name of the file. Not to be freed by caller.
	 */
	const gchar* get_filename ();

	/**
	 * ianjuta_document_can_undo:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Can the editor undo the last operation?
	 *
	 * Returns: TRUE if editor can undo, else FALSE
	 */
	gboolean can_undo();

	/**
	 * ianjuta_document_can_redo:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Can the editor redo the last operation?
	 *
	 * Returns: TRUE if editor can redo, else FALSE
	 */
	gboolean can_redo ();

	/**
	 * ianjuta_document_undo:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Undo last operation
	 */
	void undo ();

	/**
	 * ianjuta_document_redo:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Redo last undo operation
	 */
	void redo ();

	/**
	 * ianjuta_document_begin_undo_action:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Begins the mark of undoable action. Calls to this are stacked and
	 * each must be ended with ianjuta_document_end_action().
	 */
	void begin_undo_action ();

	/**
	 * ianjuta_document_end_undo_action:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Ends the mark of undoable action.
	 */
	void end_undo_action ();

	/**
	 * ianjuta_document_grab_focus:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Grabs the focus.
	 */
	void grab_focus ();

	/**
		 * ianjuta_document_cut:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Cut selection to clipboard.
		 */
		void cut ();

		/**
		 * ianjuta_document_copy:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Copy selection to clipboard.
		 */
		void copy ();

		/**
		 * ianjuta_document_paste:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Paste clipboard at current position.
		 */
		void paste ();

		/**
		 * ianjuta_document_clear:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Clear selection
		 */
		void clear ();
}

/**
 * SECTION:ianjuta-editor
 * @title: IAnjutaEditor
 * @short_description: Text editor interface
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-editor.h
 *
 */
interface IAnjutaEditor
{
	#include <gtk/gtk.h>
	#include <libanjuta/interfaces/ianjuta-iterable.h>

	/**
	* IANJUTA_EDITOR_PREF_SCHEMA
	*
	* Schema id used to store common editor settings. 
	*/
	#define PREF_SCHEMA	"editor"

	/**
	* IANJUTA_EDITOR_USE_TABS_KEY
	*
	* Boolean key, true is tabs has to be used for indenting.
	*/
	#define USE_TABS_KEY	"use-tabs"

	/**
	* IANJUTA_EDITOR_TAB_WIDTH_KEY
	*
	* Integer key, defines the size of a tabulation in spaces.
	*/
	#define TAB_WIDTH_KEY	"tab-width"

	/**
	* IANJUTA_EDITOR_INDENT_WIDTH_KEY
	*
	* Integer key, defines the number a space for one indentation step.
	*/
	#define INDENT_WIDTH_KEY	"indent-width"


	enum Error
	{
		DOESNT_EXIST
	}
  /**
   * IAnjutaEditorAttribute:
   * @IANJUTA_EDITOR_TEXT: Normal text
   * @IANJUTA_EDITOR_KEYWORD: A keyword of the programming language
   * @IANJUTA_EDITOR_COMMENT: A comment
   * @IANJUTA_EDITOR_STRING: A string
   *
   * This enumeration is used to specify the type of text. Note that not all
   * editors implement this.
   */
	enum Attribute
	{
		TEXT,
		KEYWORD,
		COMMENT,
		STRING
	}

	/**
	 * IAnjutaEditor::glade-member-add:
	 * @widget_typename: Name of the type of the widget that will become a member of the class.
	 * @widget_name: Name of the widget that will become a member of the class.
	 * @filename: Path for the .ui file that generated the signal.
	 * @obj: Self
	 *
	 * This signal is emitted when code for a widget must be generated.
	 */
	void   ::glade_member_add (gchar *widget_typename, gchar *widget_name, gchar *filename);

	/**
	 * IAnjutaEditor::glade-member-add:
	 * @widget_typename: Name of the type of the widget.
	 * @signal_name: Name of the signal.
	 * @handler_name: Name of the signal handler.
	 * @object: Name of the object to be passed.
	 * @swap: The "swap" signal property.
	 * @after: The "after" signal property.
	 * @filename: Path for the .ui file that generated the signal.
	 * @obj: Self
	 *
	 * This signal is emitted when code for a widget must be generated.
	 */
	void   ::glade_callback_add (gchar *widget_typename, gchar *signal_name, gchar *handler_name, gchar *object, gboolean swap, gboolean after, gchar *filename);

	/**
	 * IAnjutaEditor::code-added:
	 * @position: The iter position where @ch is added.
	 * @code: The code that has been added.
	 * @obj: Self
	 *
	 * This signal is emitted when code is added inside the editor.
	 * The newly added code is @code which has been inserted at @position.
	 */
	void   ::code_added (IAnjutaIterable *position, gchar *code);

	/**
	 * IAnjutaEditor::char-added:
	 * @position: The iter position where @ch is added.
	 * @ch: The character that has been added.
	 * @obj: Self
	 *
	 * This signal is emitted when any character is added inside the editor.
	 * The newly added character is @ch which has been inserted at @position.
	 */
	void   ::char_added (IAnjutaIterable *position, gchar ch);

	/**
	 * IAnjutaEditor::backspace:
	 * @obj: Self
	 *
	 * The signal is emitted when the user presses backspace
	 */
	void   ::backspace ();

	/**
	 * IAnjutaEditor::changed:
	 * @position: The iter position where change happend.
	 * @added: TRUE if added, FALSE if deleted.
	 * @length: Length of the text changed.
	 * @lines: Number of lines added or removed.
	 * @text: The text added or removed.
	 * @obj: Self
	 *
	 * This signal is emitted when any text change happens in editor.
	 * The changes begin at @position. @text is not garanteed to be NULL
	 * terminated. Use @length to read the text. @lines represent the
	 * number of line breaks in the added or removed text.
	 */
	void   ::changed (IAnjutaIterable *position, gboolean added, gint length, gint lines, const gchar *text);

	/**
	 * IAnjutaEditor::cursor-moved:
	 * @obj: Self
	 *
	 * The signal is a hint that the cursor was moved.
	 */
	void   ::cursor_moved ();

	/**
	 * IAnjutaEditor::line-marks-gutter-clicked:
	 * @obj: Self
	 * @double_click: whether the line marks gutter was double clicked
	 * @location: location of the clicked marker
	 *
	 * The signal is emitted when the user clicks on a marker
	 */
	void   ::line_marks_gutter_clicked (gint location);

	/**
	 * ianjuta_editor_get_tabsize:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Returns the tabsize (in spaces) currently used by the editor.
	 *
	 * Returns: tabsize in number of spaces
	 */
	gint   get_tabsize ();

	/**
	 * ianjuta_editor_set_tabsize:
	 * @obj: Self
	 * @tabsize: Tabsize in spaces
	 * @err: Error propagation and reporting
	 *
	 * Sets the tabsize of the editor.
	 */
	void   set_tabsize (gint tabsize);

	/**
	 * ianjuta_editor_get_use_spaces:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Returns if the editor uses spaces for filling up tab characters.
	 *
	 * Returns: TRUE if yes, FALSE if no.
	 */
	gboolean   get_use_spaces ();

	/**
	 * ianjuta_editor_set_use_space:
	 * @obj: Self
	 * @use_spaces: TRUE to use spaces, FALSE to use tab char directly.
	 * @err: Error propagation and reporting
	 *
	 * Sets if the editor should use spaces for filling up tab characters.
	 */
	void   set_use_spaces (gboolean use_spaces);

	/**
	 * ianjuta_editor_set_auto_indent:
	 * @obj: Self
	 * @auto_indent: TRUE to enable auto-indent, FALSE to disable
	 *
	 * Sets whether the editor should auto-indent itself. A plugin that does
	 * custom auto-indent can set this to false and override the preferences
	 * setting
	 */
	void set_auto_indent (gboolean auto_indent);

	/**
	 * ianjuta_editor_erase_range:
	 * @obj: Self
	 * @position_start: Start position of chars to erase.
	 * @position_end: End position of chars to erase.
	 * @err: Error propagation and reporting
	 *
	 * Erases the chars between positions pointed by @position_start and
	 * @position_end. The character pointed by @position_start is included,
	 * while pointed by @position_end is not include in the range. After
	 * the erase operation, all active iters, except these two, are no
	 * longer guranteed to be valid. At the end the operation, these two
	 * iters point to the same position which is the position where erase
	 * happend (usually the original @position_start position).
	 */
	void   erase (IAnjutaIterable *position_start, IAnjutaIterable *position_end);

 	/**
	 * ianjuta_editor_erase_all:
 	 * @obj: Self
 	 * @err: Error propagation and reporting
 	 *
	 * Empties the whole editor buffer. There will be zero characters.
	 * After the erase operation, none of the active iters are guranteed
	 * to be valid.
 	 */
	void   erase_all ();

	/**
	 * ianjuta_editor_insert:
	 * @obj: Self
	 * @position: Character position in editor where insert will take place.
	 * @text: Text to append.
	 * @length: Length of @text to use.
	 * @err: Error propagation and reporting
	 *
	 * Inserts @length characters from @text buffer at given @position of
	 * editor buffer. If @length is -1, the whole @text is used.
	 */
	void   insert (IAnjutaIterable *position, const gchar *text, gint length);

	/**
	 * ianjuta_editor_append:
	 * @obj: Self
	 * @text: Text to append.
	 * @length: Length of @text to use.
	 * @err: Error propagation and reporting
	 *
	 * Appends @length characters from @text buffer at the end of editor
	 * buffer. If @length is -1, the whole @text is used. @length is in bytes.
	 */
	void   append (const gchar *text, gint length);

	/**
	 * ianjuta_editor_goto_line:
	 * @obj: Self
	 * @lineno: line number where carat will be moved.
	 * @err: Error propagation and reporting
	 *
	 * Carat is moved to the given @lineno line and text view is scrolled to
	 * bring it in viewable area of the editor.
	 */
	void   goto_line (gint lineno);

	/**
	 * ianjuta_editor_goto_start:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Carat is moved to the begining of editor and text view is scrolled to
	 * bring it in viewable area of the editor.
	 */
	void   goto_start ();

	/**
	 * ianjuta_editor_goto_end:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Carat is moved to the end of editor and text view is scrolled to
	 * bring it in viewable area of the editor.
	 */
	void   goto_end ();

	/**
	 * ianjuta_editor_goto_position:
	 * @obj: Self
	 * @position: Character position where carat will be moved.
	 * @err: Error propagation and reporting
	 *
	 * Carat is moved to the given @position and text view is scrolled to
	 * bring @position in viewable area of the editor.
	 */
	void goto_position (IAnjutaIterable *position);

	/**
	 * ianjuta_editor_get_text:
	 * @obj: Self
	 * @begin: Begining iterator
	 * @end: End iterator
	 * @err: Error propagation and reporting
	 *
	 * Gets text characters beginning from @begin (including char
	 * pointed by @begin) and ending with @end (excluding character
	 * pointed by @end). The characters returned are utf-8 encoded.
	 * The iterators @begin and @end could be in either order. The returned
	 * text, however, is in right order. If both @begin and @end points
	 * to the same position, NULL is returned.
	 *
	 * Returns: A buffer of utf-8 characters.
	 * The returned buffer must be freed when no longer required.
	 */
	gchar* get_text (IAnjutaIterable *begin, IAnjutaIterable *end);

	/**
	 * ianjuta_editor_get_text_all:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Gets all text characters in the editor.
	 * The characters returned are utf-8 encoded.
	 *
	 * Returns: A buffer of utf-8 characters containing all text from editor.
	 * The returned buffer must be freed when no longer required.
	 */
	gchar* get_text_all ();

	/**
	 * ianjuta_editor_line_from_position:
	 * @obj: Self
	 * @position: Position you want to know the line from
	 * @err: Error propagation and reporting
	 *
	 * Get the line number in which @position locates.
	 * Returns: Line which corresponds to @position
	 *
	 */
	int get_line_from_position (IAnjutaIterable *position);

	/**
	 * ianjuta_editor_get_lineno:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Obtains current line number on which carat is.
	 *
	 * Return value: Line number.
	 */
	gint   get_lineno ();

	/**
	 * ianjuta_editor_get_length:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get length of complete text in editor. This will be the total
	 * number of bytes in the file or buffer.
	 *
	 * Return value: Text length.
	 */
	gint   get_length ();

	/**
	 * ianjuta_editor_get_current_word:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Obtains the word on which carat is currently on.
	 *
	 * Return value: Current word.
	 */
	gchar* get_current_word ();

	/**
	 * ianjuta_editor_get_current_column:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Obtains number of the current column in the editor.
	 *
	 * Return value: Current column.
	 */
	gint get_column ();

	/**
	 * ianjuta_editor_get_line_begin_position:
	 * @obj: Self
	 * @line: fixme
	 * @err: Error propagation and reporting.
	 *
	 * fixme
	 *
	 * Returns: (transfer full): fixme
	 */
	IAnjutaIterable* get_line_begin_position (gint line);

	/**
	 * ianjuta_editor_get_line_end_position:
	 * @obj: Self
	 * @line: fixme
	 * @err: Error propagation and reporting.
	 *
	 * fixme
	 *
	 * Returns: (transfer full): fixme
	 */
	IAnjutaIterable *get_line_end_position (gint line);

	/**
	 * ianjuta_editor_get_overwrite:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Obtains editor overwirte mode: TRUE = Override, FALSE = Insert.
	 *
	 * Return value: editor mode.
	 */
	gboolean get_overwrite ();


	/**
	 * ianjuta_editor_set_popup_menu:
	 * @obj: Self
	 * @menu: Popupmenu
	 * @err: Error propagation and reporting
	 *
	 * Set Editor popup menu. This is the menu shown in the editor when one
	 * right-clicks on it.
	 *
	 */
	void set_popup_menu (GtkWidget *menu);

	/*
	 * ianjuta_editor_get_offset:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get current caret position in integer character offset. Deprecated.
	 * Use ianjuta_editor_get_position() instead.
	 *
	 * Returns: Current character position since the begining of file.
	 */
	gint   get_offset ();

	/**
	 * ianjuta_editor_get_position:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get current caret position.
	 *
	 * Returns: (transfer full): Iterator that points to the current position.
	 */
	IAnjutaIterable*   get_position ();

	/**
	 * ianjuta_editor_get_position_from_offset:
	 * @obj: Self
	 * @offset: Character offset position where the iter will be set
	 * @err: Error propagation and reporting
	 *
	 * Creates and returns an iter for editor cells. The iter is
	 * placed at the unicode character position where the given offset
     * @offset happens to fall. The returned iter is cell (character)
	 * iter and not byte iter, so all iter operations
	 * on it are character (not byte) iteration, including all position
     * and index references in the iter.
     *
     * The iter must be unreferrenced by the caller when done.
	 * The iter navigates (next/previous) in step of unicode
	 * characters (one unicode character == one cell).
	 *
	 * Retrun value: a newly created iter of IAnjutaEditorCell placed at the
	 * given @offset position.
	 */
	IAnjutaIterable* get_position_from_offset (gint offset);

	/**
	 * ianjuta_editor_get_start_position:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Gets the iter positioned at the start of the editor buffer.
	 *
	 * Return value: (transfer none): Cell iter set to the begining of the editor.
	 */
	IAnjutaIterable* get_start_position ();

	/**
	 * ianjuta_editor_get_end_position:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Gets the iter positioned at the end of the editor buffer. The
	 * returned iter is the end-iter which does not point to any valid
	 * character in the buffer (it is pointed one step beyond the last
	 * valid character).
	 *
	 * Return value: (transfer none): Cell iter set to the end of the editor (end-iter).
	 */
	IAnjutaIterable* get_end_position ();

	/**
	 * SECTION:ianjuta-editor-selection
	 * @title: IAnjutaEditorSelection
	 * @short_description: Text editor selection interface
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-editor-selection.h
	 *
	 */
	interface IAnjutaEditorSelection
	{
		#include <libanjuta/interfaces/ianjuta-editor-cell.h>
		/**
		 * ianjuta_editor_selection_has_selection:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Returns TRUE if editor has any text selected. The selection
		 * positions can be retrieved with ianjuta_editor_selection_get_start()
		 * and ianjuta_editor_selection_get_end().
		 *
		 * Returns: TRUE if there is text selected else FALSE.
		 */
		gboolean has_selection ();

		/**
		 * ianjuta_editor_selection_get:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Gets curerntly selected text in editor.
		 *
		 * Returns: A newly allocated buffer of currently selected characters.
		 * NULL if there is no selection. The returned buffer must be freed after
		 * use.
		 */
		gchar* get ();

		/**
		 * ianjuta_editor_selection_set:
		 * @obj: Self
		 * @start: Begin of selection
		 * @end: End of selection
		 * @scroll: Scroll selection onscreen
		 * @err: Error propagation and reporting
		 *
		 * Select characters between start and end. Start and end don't have to
		 * be ordered.
		 */
		void set (IAnjutaIterable* start, IAnjutaIterable* end, gboolean scroll);

		/**
		 * ianjuta_editor_selection_get_start:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Gets start position of selection text.
		 *
		 * Return: Start of selection or NULL if there is no selection.
		 */
		IAnjutaIterable* get_start ();

		/**
		 * ianjuta_editor_selection_get_end:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Get end position of selection. If there is no selection, returns
		 * NULL.
		 *
		 * Returns: End of selection or NULL if there is no selection.
		 */
		IAnjutaIterable* get_end ();

		/**
		 * ianjuta_editor_selection_select_block:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Selects current block of code. The definition of block of code
		 * depends on highlight mode used (programming language). Some
		 * highlight mode does not have block concept, in that case this
		 * method does not do anything.
		 */
		void select_block ();

		/**
		 * ianjuta_editor_selection_select_function:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Select current function block. The definition of function block
		 * depends on highlight mode used (programming language). Some
		 * highlight mode does not have function concept, in that case this
		 * method does not do anything.
		 */
		void select_function ();

		/**
		 * ianjuta_editor_edit_select_all:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Select whole buffer.
		 */
		void select_all ();

		/**
		 * ianjuta_editor_selection_replace:
		 * @obj: Self
		 * @text: Replacement text.
		 * @length: Length of the text to used in @text.
		 * @err: Error propagation and reporting
		 *
		 * Replaces currently selected text with the @text. Only @length amount
		 * of characters are used from @text buffer to replace.
		 */
		void replace (const gchar *text, gint length);
	}

	/**
	 * SECTION:ianjuta-editor-search
	 * @title: IAnjutaEditorSearch
	 * @short_description: Text editor search interface
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-editor-search.h
	 *
	 */
	interface IAnjutaEditorSearch
	{
	  #include <libanjuta/interfaces/ianjuta-editor-cell.h>

		/**
		 * ianjuta_editor_search_forward:
		 * @obj: Self
		 * @search: String to search for
		 * @start: Where to search from
	 	 * @end: Where to stop searching
		 * @result_start: (out): Will be set to the start of the search_result (or NULL)
		 * @result_end: (out): Will be set to the end of the search_result (or NULL)
	 	 * @err: Error propagation and reporting
	 	 *
	 	 * Search forward from start to end
	 	 *
	 	 */
		gboolean forward (const gchar* search, gboolean case_sensitive, IAnjutaEditorCell* start, IAnjutaEditorCell* end, IAnjutaEditorCell** result_start, IAnjutaEditorCell** result_end);

		/**
		 * ianjuta_editor_search_backward:
		 * @obj: Self
		 * @search: String to search for
		 * @start: Where to search from
		 * @end: Where to stop searching
		 * @result_start: (out): Will be set to the start of the search_result (or NULL)
		 * @result_end: (out): Will be set to the end of the search_result (or NULL)
		 * @err: Error propagation and reporting
		 *
		 * Search backward from end to start
		 *
		 */

		 gboolean backward (const gchar* search, gboolean case_sensitive, IAnjutaEditorCell* start, IAnjutaEditorCell* end, IAnjutaEditorCell** result_start, IAnjutaEditorCell** result_end);
	}


	/**
	 * SECTION:ianjuta-editor-convert
	 * @title: IAnjutaEditorConvert
	 * @short_description: Text editor convert interface
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-editor-convert.h
	 *
	 */
	interface IAnjutaEditorConvert
	{
		/**
		 * ianjuta_editor_convert_to_upper:
		 * @obj: Self
		 * @start_position: Start position.
		 * @end_position: End position.
		 * @err: Error propagation and reporting
		 *
		 * change characters from start position to end position to uppercase.
		 *
		 */
		void to_upper (IAnjutaIterable *start_position, IAnjutaIterable *end_position);

		/**
		 * ianjuta_editor_convert_to_lower:
		 * @obj: Self
		 * @start_position: Start position.
		 * @end_position: End position.
		 * @err: Error propagation and reporting
		 *
		 * change characters from start position to end position to lowercase
		 *
		 */
		void to_lower (IAnjutaIterable *start_position, IAnjutaIterable *end_position);
	}

	/**
	 * SECTION:ianjuta-editor-line-mode
	 * @title: IAnjutaEditorLineMode
	 * @short_description: Text editor line mode
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-editor-line-mode.h
	 *
	 */
	interface IAnjutaEditorLineMode
	{
	/**
   * IAnjutaEditorLineModeType:
   * @IANJUTA_EDITOR_LINE_MODE_LF: Line-Feed (Unix)
   * @IANJUTA_EDITOR_LINE_MODE_CR: Carat return (Max)
   * @IANJUTA_EDITOR_LINE_MODE_CRLF: Caret return + line-feed (Windows)
   *
   * This enumeration is used to specify the type of text. Note that not all
   * editors implement this.
   */
		enum Type
		{
			LF,
			CR,
			CRLF
		}

		/**
		 * ianjuta_editor_line_mode_get:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Get current line ending mode. It is auto-detected from the
		 * buffer contents.
		 */
		Type get ();

		/**
		 * ianjuta_editor_line_mode_set:
		 * @obj: Self
		 * @mode: Line mode to set.
		 * @err: Error propagation and reporting
		 *
		 * Set the line ending mode to the given @mode. Existing line end
		 * characters in the buffer are not touched. Only the newly added
		 * texts will have @mode line end characters.
		 */
		void set (Type mode);

		/**
		 * ianjuta_editor_line_mode_convert:
		 * @obj: Self
		 * @mode: Line mode to convert.
		 * @err: Error propagation and reporting
		 *
		 * Set the line ending mode to the given @mode and convert all line end
		 * characters in the buffer to @mode line end characters.
		 */
		void convert (Type mode);

		/**
		 * ianjuta_editor_line_mode_fix:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Convert EOL characters to majority of line mode. This is helpful
		 * when the buffer contains mixed line modes and we want to fix it.
		 */
		void fix ();
	}

	/**
	 * SECTION:ianjuta-editor-tip
	 * @title: IAnjutaEditorTip
	 * @short_description: Editor call tips assistance framework
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-editor-tip.h
	 *
	 */
	interface IAnjutaEditorTip
	{
		/**
		 * ianjuta_editor_tip_show:
		 * @obj: Self
		 * @tips: (element-type utf8): list of alternative tips.
		 * @position: Tip position.
		 * @err: Error propagation and reporting
		 *
		 * Show tips showing more information on current context. No user feedback
		 * is required when tips are shown. @position indicates
		 * the position before which is the known context and after which are
		 * the suggestions. Usually the editor would use this to
		 * align the choices displayed such that the carat is just at this
		 * position when the choices are displayed.
		 *
		 */
		void show (List<const gchar*> tips, IAnjutaIterable *position);

		/**
		 * ianjuta_editor_tip_cancel
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Cancels the last shown tooltip
		 */
		void cancel ();

		/**
		 * ianjuta_editor_tip_visible:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Returns: whether a tooltip is crrently shown
		 */
		gboolean visible();
	}

	/**
	 * SECTION:ianjuta-editor-assist
	 * @title: IAnjutaEditorAssist
	 * @short_description: Text editor assist interface
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-editor-assist
	 *
	 */
  interface IAnjutaEditorAssist
	{
     #include <libanjuta/interfaces/ianjuta-provider.h>

     struct Proposal
     {
        gchar* label;
        gchar* markup;
        gchar* info;
        gchar* text;
        GdkPixbuf* icon;
        gpointer data;
     }

    /**
	 * IAnjutaEditorAssist::cancelled
	 * @obj: Self
	 *
	 * This signal is emitted when the autocompletion is cancelled due to various
	 * reasons. The provider should avoid to call ianjuta_editor_assist_proposals() after
	 * this signal.
	 */
	 void   ::cancelled ();

     /*
      * ianjuta_editor_assist_add
      * @obj: self
      * @provider: a IAnjutaProvider
      * @err: Error handling
      *
      * Add a provider to the list of completion providers
      */
      void add(IAnjutaProvider* provider);

     /*
      * ianjuta_editor_assist_remove
      * @obj: self
      * @provider: a IAnjutaProvider
      * @err: Error handling
      *
      * Remove a provider from the list of completion providers
      */
      void remove(IAnjutaProvider* provider);

     /*
      * ianjuta_editor_assist_invoke
      * @obj: self
      * @provider: a IAnjutaProvider (can be NULL to use all providers)
      * @err: Error handling
      *
      * Force invokation of a provider at the current cursor position.
      * That means that ianjuta_provider_populate() will be called on the
      * provider.
      */
      void invoke(IAnjutaProvider* provider);

     /**
      * ianjuta_editor_assist_proposals:
      * @obj: self
      * @provider: a IAnjutaProvider
      * @proposals: (element-type IAnjutaEditorAssistProposal): a list of IAnjutaProposals
      * @pre_word: the word before the cursor
      * @finished: whether is was the last call in an async operation
      * @err: Error handling
      *
      * Add the list of proposals for the current population. You can add
      * proposals async as long as the last call sets finished to TRUE. That
      * is usually called by the IAnjutaProvider after it was triggered by
      * ianjuta_provider_populate()
      *
      */
      void proposals(IAnjutaProvider* provider, GList* proposals, const gchar* pre_word, gboolean finished);
	}

	/**
	 * SECTION:ianjuta-editor-hover
	 * @title: IAnjutaEditorHover
	 * @short_description: Text editor hover interface
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-editor-hover
	 *
	 */
	interface IAnjutaEditorHover
	{
	  #include <libanjuta/interfaces/ianjuta-iterable.h>

	  /* IAnjutaEditorHover::hover-over:
		 * @obj: self
		 * @position: IAnjutaEditorCell specifying the position the mouse is over
		 *
		 * The mouse is held for a moment over @position. This can be used to show
		 * all tooltip.
		 */
		void ::hover_over (IAnjutaIterable* position);

	  /* IAnjutaEditorHover::hover-leave
		 * @obj: self
		 * @position: IAnjutaEditorCell specifying the position the mouse was over
		 *
		 * User moved the mouse away - can be used to clean up things done in
		 * #IAnjutaEditorHover::hover-over
		 */
		void ::hover_leave (IAnjutaIterable* position);

		/**
		 * ianjuta_editor_hover_display:
		 * @obj: Self
		 * @info: String to display
		 * @err: Error propagation and reporting
		 *
     	 * Show @info as tooltip
		 *
		 */
		void display (IAnjutaIterable* position, const gchar *info);
	}

	/**
	 * SECTION:ianjuta-editor-language
	 * @title: IAnjutaEditorLanguage
	 * @short_description: Text editor language interface
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-editor-language.h
	 *
	 */
	interface IAnjutaEditorLanguage
	{
	  /* IAnjutaEditorLanguage::language-changed:
		 * @obj: self
		 * @language: new language
		 *
		 * the language of the editor changed to @language
		 */
		void ::language_changed (const gchar *language);

		/**
		 * ianjuta_editor_language_get_supported_languages:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Return a list of languages supported by the editor
		 * Note: These list contains the names in the form
		 * the editor implementation knows them
		 * Returns: (element-type utf8):
		 */

		const List<const gchar*> get_supported_languages ();

		/**
		 * ianjuta_editor_language_name:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Get a list of languages the editor can highlight
		 *
		 */

		const gchar *get_language_name (const gchar* language);

		/**
		 * ianjuta_editor_language_get_language:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Return the name of the currently used language
		 *
		 */

		const gchar *get_language ();

		/**
		 * ianjuta_editor_language_set_language:
		 * @obj: Self
		 * @language: Language
		 * @err: Error propagation and reporting
		 *
		 * Force the editor to use a given language
		 *
		 */

		void set_language (const gchar* language);
	}

	/**
	 * SECTION:ianjuta-editor-folds
	 * @title: IAnjutaEditorFolds
	 * @short_description: Text editor folds inteface
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-editor-folds.h
	 *
	 */
	interface IAnjutaEditorFolds
	{
		/**
		 * ianjuta_editor_view_open_folds:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Open all folds
		 *
		 */
		void open_all ();

		/**
		 * ianjuta_editor_view_close_folds:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Close all folds
		 *
		 */
		void close_all ();

		/**
		 * ianjuta_editor_view_toggle_fold:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Open/Close current fold
		 *
		 */
		void toggle_current ();
	}

	/**
	 * SECTION:ianjuta-editor-view
	 * @title: IAnjutaEditorView
	 * @short_description: Text editor view interface
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-editor-view.h
	 *
	 * An editor view is a visual representation of the editor. An editor
	 * can have multiple views. All views of an editor show the same editor
	 * content (buffer). Consequently, any change done in one view is
	 * updated in all other views.
	 */
	interface IAnjutaEditorView
	{
		/**
		 * ianjuta_editor_view_create:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Creates a new view for the editor. The newly created view gets
		 * the user focus and scrolls to the same location as last view.
		 */
		void create ();

		/**
		 * ianjuta_editor_view_remove_current:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Removes currently focused editor view. It does not remove the
		 * last view of the editor. That is, if currently there is only
		 * one view of the editor, this function does nothing.
		 */
		void remove_current ();

		/**
		 * ianjuta_editor_view_get_count:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Total number of views currently present. It will never be less
		 * than 1. Invalid return values are considered error condition.
		 */
		gint get_count ();
	}

	/**
	 * SECTION:ianjuta-editor-comment
	 * @title: IAnjutaEditorComment
	 * @short_description: Text editor comment interface
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-editor-comment.h
	 *
	 */
	interface IAnjutaEditorComment
	{
		/**
		 * ianjuta_editor_comment_block:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Comment/Uncomment out selected block
		 */
		void block();

		/**
		 * ianjuta_editor_comment_box:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Comment/Uncomment out selected block
		 */
		void box();

		/**
		 * ianjuta_editor_comment_stream:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Comment/Uncomment out selected block
		 */
		void stream();
	}

	/**
	 * SECTION:ianjuta-editor-zoom
	 * @title: IAnjutaEditorZoom
	 * @short_description: Text editor zoom interface
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-editor-zoom.h
	 *
	 */
	interface IAnjutaEditorZoom
	{
		/**
		 * ianjuta_editor_zoom_in:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Zoom in
		 */
		void in ();

		/**
		 * ianjuta_editor_zoom_out:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Zoom out
		 */
		void out ();
	}

	/**
	 * SECTION:ianjuta-editor-goto
	 * @title: IAnjutaEditorGoto
	 * @short_description: Text editor navigation interface
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-editor-goto.h
	 *
	 */
	interface IAnjutaEditorGoto
	{
		/**
		 * ianjuta_editor_goto_start_block:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Moves cursor to the start of the current block
		 */
		void start_block();

		/**
		 * ianjuta_editor_goto_end_block:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Moves cursor to the end of the current block
		 */
		void end_block();

		/**
		 * ianjuta_editor_goto_matching_brace:
		 * @obj: Self
		 * @err: Error propagation and reporting
		 *
		 * Moves cursor to matching brace
		 */
		void matching_brace();

	}

	/**
	 * SECTION:ianjuta-editor-glade-signal
	 * @title: IAnjutaEditorGladeSignal
	 * @short_description: Interface for dropping signal handlers
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-editor-goto.h
	 *
	 */
	interface IAnjutaEditorGladeSignal
	{
		/* IAnjutaEditorGladeSignal::drop-possible
		 * @obj: self
		 * @iter: a IAnjutaIterable of the position where drop would happen
		 *
		 * Emitted when a signal is dragged over the editor
		 *
		 * Return value: TRUE if a signal handler can be dropped, FALSE otherwise
		 */
		gboolean ::drop_possible (IAnjutaIterable* iterator);

		/* IAnjutaEditorGladeSignal::drop
		 * @obj: self
		 * @iter: a IAnjutaIterable of the position where drop happens
		 * @signal_data: Signal data in form "widget:signal:handler", e.g.
		 * "GtkToggleButton:toggled:on_toggle_button_toggled"
		 *
		 * Emitted when a signal was received per drag & drop
		 *
		 */
		void ::drop (IAnjutaIterable* iterator, const gchar* signal_data);
	}
}

/**
 * SECTION:ianjuta-editor-cell
 * @title: IAnjutaEditorCell
 * @short_description: Text editor character cell
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-editor-cell.h
 *
 * Represents a cell in editor. A cell corresponds to a unicode
 * character along with all associated styles (such as colors and font).
 * A cell may or may not have style. If style is supported in the
 * editor, it is assumed all cells will have styles and hence every
 * IAnjutaEditorCell interface instance will have additionally
 * IAnjutaEditorCellStyle implemented.
 */
interface IAnjutaEditorCell
{
	#include <libanjuta/interfaces/ianjuta-editor.h>

	/**
	 * ianjuta_editor_cell_get_character:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Returns the unicode character in this cell. A NULL terminated
	 * string is returned that is the multibyte unicode character.
	 * NULL is returned if the cell does not have any character.
	 *
	 * Returns: a newly created string representing the cell's unicode
	 * character.
	 */
	gchar *get_character ();

	/**
	 * ianjuta_editor_cell_get_length:
	 * @obj: self
	 * @err: Error propagation and reporting.
	 *
	 * Gets the length of the cell in bytes. That is, length of the
	 * unicode character.
	 *
	 * Returns: Length of the unicode character.
	 */
	gint get_length ();

	/**
	 * ianjuta_editor_cell_get_char:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Returns the byte of the unicode character in this cell at given
	 * index @char_index. @char_index can vary from 0 to length of the
	 * unicode string minus 1. Out of range index is not allowed
	 * (asserted) and return is undefined.
	 *
	 * Since there is dynamic allocation of unicode character string
	 * involved in ianjuta_editor_cell_get_character(), this function
	 * is mainly useful for fast iteration (such as copying data).
	 *
	 * Returns: a byte character.
	 */
	gchar get_char (gint char_index);

	IAnjutaEditorAttribute get_attribute ();

	/**
	 * SECTION:ianjuta-editor-cell-style
	 * @title: IAnjutaEditorCellStyle
	 * @short_description: Text editor cell style interface
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-editor-cell-style.h
	 *
	 */
	interface IAnjutaEditorCellStyle
	{
		gchar* get_font_description ();
		gchar* get_color();
		gchar* get_background_color();
	}
}

/**
 * SECTION:ianjuta-editor-factory
 * @title: IAnjutaEditorFactory
 * @short_description: Text editor factory that creates IAnjutaEditor objects
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-editor-factory.h
 *
 */
interface IAnjutaEditorFactory
{
	#include "ianjuta-editor.h"
	#include <gio/gio.h>

	/**
	 * ianjuta_editor_factory_new_editor:
	 * @obj: Self
	 * @file: file to open
	 * @filename: filename to open
	 * @err: Error propagation and reporting
	 *
	 * Get a new GtkWidget* which implements IAnjutaEditor
	 *
	 * Return value: An object implementing IAnjutaEditor
	 */
	IAnjutaEditor* new_editor (GFile* file, const gchar* filename);
}

/**
 * SECTION:ianjuta-provider
 * @title: IAnjutaProvider
 * @short_description: Provider for autocompletion features
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-provider.h
 */
interface IAnjutaProvider
{
	#include "ianjuta-iterable.h"

	/**
	 * ianjuta_provider_populate:
	 * @obj: Self
	 * @iter: the text iter where the provider should be populated
	 * @err: Error propagation and reporting.
	 *
	 * Show completion for the context at position @iter. The provider should
	 * call ianjuta_editor_assist_proposals here to add proposals to the list.
	 *
	 * Note that this is called after every character typed and the list of proposals
	 * has to be completely renewed.
	 */
	void populate(IAnjutaIterable* iter);

	/**
	 * ianjuta_provider_get_start_iter:
	 * @obj: Self
	 * @err: Error propagation and reporting.
	 *
	 * Get the iter where the current completion started
	 *
	 * Returns: (transfer none): current start iter
	 */
	IAnjutaIterable* get_start_iter();

	/**
	 * ianjuta_provider_activate:
	 * @obj: Self
	 * @iter: position where the completion occurs
	 * @data: data assigned to the proposal
	 * @err: Error propagation and reporting.
	 *
	 * Show completion for the context at position @iter
	 */
	void activate(IAnjutaIterable* iter, gpointer data);

	/**
	 * ianjuta_provider_get_name:
	 * @obj: Self
	 *
	 * Return a (translatable) name for the provider
	 */
	const gchar* get_name();
	
	/**
	 * SECTION:ianjuta-language-provider
	 * @title: IAnjutaLanguageProvider
	 * @short_description: Provider for autocompletion features
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-language-provider.h
	 */
	interface IAnjutaLanguageProvider
	{
		#include "ianjuta-editor.h"
		#include "ianjuta-iterable.h"
		#include "ianjuta-symbol.h"
		
		/**
		 * IANJUTA_LANGUAGE_PROVIDER_PREF_CALLTIP_ENABLE
		 *
		 * Boolean key, true is calltips has to be shown.
		 */
		 #define PREF_CALLTIP_ENABLE                      "calltip-enable"
		 
		/**
		 * IANJUTA_LANGUAGE_PROVIDER_PREF_AUTOCOMPLETE_ENABLE
		 *
		 * Boolean key, true is code completion is enable.
		 */
		 #define PREF_AUTOCOMPLETE_ENABLE                 "completion-enable"
		 
		/**
		 * IANJUTA_LANGUAGE_PROVIDER_PREF_AUTOCOMPLETE_SPACE_AFTER_FUNC
		 *
		 * Boolean key, true is adding a space after function call autocompletion
		 */
		 #define PREF_AUTOCOMPLETE_SPACE_AFTER_FUNC       "completion-space-after-func"
		 
		/**
		 * IANJUTA_LANGUAGE_PROVIDER_PREF_AUTOCOMPLETE_BRACE_AFTER_FUNC
		 *
		 * Boolean key, true is adding '(' after function call autocompletion
		 */
		 #define PREF_AUTOCOMPLETE_BRACE_AFTER_FUNC       "completion-brace-after-func"
		 
		/**
		 * IANJUTA_LANGUAGE_PROVIDER_PREF_AUTOCOMPLETE_CLOSEBRACE_AFTER_FUNC
		 *
		 * Boolean key, true is adding ')' after function call autocompletion
		 */
		 #define PREF_AUTOCOMPLETE_CLOSEBRACE_AFTER_FUNC  "completion-closebrace-after-func"
		 
		/**
		 * IAnjutaLanguageProviderProposalData:
		 * @name: Name of the object
		 * @info: Info about the object
		 * @is_func: If this is a function
		 * @has_para: If the function has at least one parameters
		 * @type: Type of the object
		 */
		struct ProposalData
		{
			gchar* name;
			gchar *info;
			gboolean is_func;
			gboolean has_para;
			IAnjutaSymbolType type;
		}

		/**
		 * ianjuta_language_provider_get_calltip_cache:
		 * @obj: Self
		 * @call_context: name of the method to show a calltip
		 * @err: Error propagation
		 *
		 * Searches for a calltip in the cache
		 *
		 * Returns: (element-type utf8) (transfer container): tips for the
		 *          searched name of the method from the cache,
		 *          NULL if nothing found
		 */
		List<gchar*> get_calltip_cache (gchar* call_context);
		 
		/**
		 * ianjuta_language_provider_get_calltip_context:
		 * @obj: Self
		 * @iter: current cursor position
		 * @err: Error propagation
		 *
		 * Searches for a calltip context
		 *
		 * Returns: name of the method to show a calltip for or NULL
		 */
		gchar* get_calltip_context (IAnjutaIterable* iter);
		 
		/**
		 * ianjuta_language_provider_new_calltip:
		 * @obj: Self
		 * @call_context: name of the method to create a new calltip
		 * @iter: current cursor position
		 * @err: Error propagation
		 *
		 * Creates a new calltip
		 */
		void new_calltip (gchar* call_context, IAnjutaIterable* iter);
		 
		/**
		 * ianjuta_language_provider_populate_language:
		 * @obj: Self
		 * @iter: the text iter where the provider should be populated
		 * @err: Error propagation and reporting.
		 *
		 * Show completion for the context at position @iter. The provider should
		 * call ianjuta_editor_assist_proposals here to add proposals to the list.
		 *
		 * Note that this is called after every character typed and the list of proposals
		 * has to be completely renewed.
		 *
		 * Returns: (transfer full): the iter where the provider populated, NULL otherwise
		 */
		IAnjutaIterable* populate_language (IAnjutaIterable* iter);
	}
}

/**
 * SECTION:ianjuta-document-manager
 * @title: IAnjutaDocumentManager
 * @short_description: Interface for plugin that manages all the editors
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-document-manager.h
 *
 */
interface IAnjutaDocumentManager
{
	#include "ianjuta-document.h"
	#include "ianjuta-editor.h"
	#include <gio/gio.h>

	/**
	* IANJUTA_DOCUMENT_MANAGER_CURRENT_DOCUMENT
	*
	* Anjuta shell value set by document manager to the current document
	*/
	#define CURRENT_DOCUMENT		"document_manager_current_document"

	enum Error
	{
		DOESNT_EXIST
	}

	/**
	 * ianjuta_document_manager_get_file:
	 * @obj: Self
	 * @filename: short filename
	 * @err: Error propagation and reporting.
	 *
	 * Given the short filename, finds the file of the filename, if the
	 * editor that has it loaded is found. If there is no editor that has
	 * this file opened, returns NULL.
	 *
	 * Return value: (transfer full): the GFile for the given short filename
	 */
	GFile* get_file (const gchar *filename);

	/**
	 * ianjuta_document_manager_find_document_with_file:
	 * @obj: Self
	 * @file: The file to find.
	 * @err: Error propagation and reporting.
	 *
	 * Finds the document that has the file  loaded. Only
	 * the editor that matches the file will be searched.
	 *
	 * Return value: (transfer none): the document that corresponds to given file. NULL if
	 * there is no editor loaded with this file.
	 */
	IAnjutaDocument* find_document_with_file (GFile* file);

	/**
	 * ianjuta_document_manager_goto_file_line:
	 * @obj: Self
	 * @file: file to go to.
	 * @lineno: the line number in the file to go to.
	 * @err: Error propagation and reporting.
	 *
	 * Loads the given file if not loaded yet, set its editor as current editor
	 * and moves cursor to the given line in the editor.
	 *
	 * Return value: (transfer none): the editor where the mark has been put. NULL if none.
	 */
	IAnjutaEditor* goto_file_line (GFile* file, gint lineno);

	/**
	 * ianjuta_document_manager_goto_file_line_mark:
	 * @obj: Self
	 * @file: file to go to.
	 * @lineno: the line number in the file to go to.
	 * @mark: TRUE if the line should be marked with a marker.
	 * @err: Error propagation and reporting
	 *
	 * Loads the given file if not loaded yet, set its editor as current editor
	 * and moves cursor to the given line in the editor. Optionally also marks
	 * the line with line marker if @mark is given TRUE.
	 *
	 * Return value: (transfer none): the editor where the mark has been put. NULL if none.
	 */
	IAnjutaEditor* goto_file_line_mark (GFile* file, gint lineno, gboolean mark);

	/**
	 * ianjuta_document_manager_get_current_document:
	 * @obj: Self
	 * @err: Error propagation and reporting.
	 *
	 * Gets the current document.
	 *
	 * Return value: (transfer none): the currently active document. NULL if none is there.
	 */
	IAnjutaDocument* get_current_document ();

	/**
	* ianjuta_document_manager_set_current_document:
	* @obj: Self
	* @document: the document to set as current.
	* @err: Error propagation and reporting.
	*
	* Sets the given document as current document.
	*/
	void set_current_document (IAnjutaDocument *document);

	/**
	 * ianjuta_document_manager_get_doc_widgets:
	 * @obj: Self
	 * @err: Error propagation and reporting.
	 *
	 * Gets a list of widgets for open documents. Each widget is
	 * a GTK_WIDGET(IAnjutaDocument*)
	 *
	 * Return value: (element-type GtkWidget) (transfer container): a list of widgets for
	 * all open documents. The returned list (but not the data in the list) must be
	 * freed after use.
	 */
	List<GtkWidget*> get_doc_widgets ();

	/**
	 * ianjuta_document_manager_add_buffer:
	 * @obj: Self
	 * @name: Name of the editor buffer.
	 * @content: Initial content of the buffer.
	 * @err: Error propagation and reporting.
	 *
	 * Creates a new editor buffer of the given name and sets the given
	 * content as its initial content.
	 *
	 * Return value: (transfer full): the IAnjutaEditor instance that has been added.
	 */
	IAnjutaEditor* add_buffer (const gchar *name, const gchar* content);

	/**
	* ianjuta_document_manager_remove_document:
	* @obj: Self
	* @document: Document to close.
	* @save_before: If true, saves the document before closing.
	* @err: Error propagation and reporting.
	*
	* Closes and removes the given document. If @save_before is TRUE, also
	* saves the document before closing.
	*
	* Return value: TRUE if the document was removed, else FALSE.
	*/
	gboolean remove_document (IAnjutaDocument *document, gboolean save_before);

	/**
	* ianjuta_document_manager_add_document:
	* @obj: Self
	* @document: the document to add
	* @err: Error propagation and reporting.
	*
	* Adds a document to the document manager. This will open a new
	* Notebook tab and show the document there
	*
	*/
	void add_document (IAnjutaDocument* document);

	/*
	 * ianjuta_document_manager_add_bookmark:
	 * @obj: Self
	 * @file: File to add the bookmark
	 * @line: Line of the bookmark
	 *
	 * Add a bookmark
	 */
	 void add_bookmark (GFile* file, gint line);
}

/**
 * SECTION:ianjuta-message-view
 * @title: IAnjutaMessageView
 * @short_description: A view where messages of different kind can be shown
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-message-view.h
 *
 */
interface IAnjutaMessageView
{
  /**
   * IAnjutaMessageViewType:
   * @IANJUTA_MESSAGE_VIEW_TYPE_NORMAL: Normal message
   * @IANJUTA_MESSAGE_VIEW_TYPE_INFO: Info message (highlighed)
   * @IANJUTA_MESSAGE_VIEW_TYPE_ERROR: Error message
   * @IANJUTA_MESSAGE_VIEW_TYPE_WARNING: Warning message
   *
   * Speficy the type ot the message added to the message view
   */
	enum Type
	{
		TYPE_NORMAL,
		TYPE_INFO,
		TYPE_WARNING,
		TYPE_ERROR
	}

	/**
	* IAnjutaMessageView::message-clicked:
	* @obj: Self
	* @message: text of the clicked message
	*
	* Emitted when the user clicks on a message
	*/
	void ::message_clicked (const gchar *message);

	/**
	* IAnjutaMessageView::buffer-flushed:
	* @obj: Self
	* @line: the current line
	*
	* Emitted when #ianjuta_message_view_buffer_append found a newline
	*/
	void ::buffer_flushed (const gchar *line);

	/**
	* ianjuta_message_view_buffer_append:
	* @obj: Self
	* @text: text to show as message
	* @err: Error propagation and reporting.
	*
	* Appends the text in buffer. Flushes the buffer where a newline is found.
  * by emiiting buffer_flushed signal. The string is expected to be utf8.
  */
	void buffer_append (const gchar *text);

	/**
	* ianjuta_message_view_append:
	* @obj: Self
	* @type: type of the message
	* @summary: summary of the message
	* @details: details of the message
	* @err: Error propagation and reporting.
	*
	* Append the message with summary displayed and details displayed as tooltip
	*/
	void append (Type type, const gchar *summary, const gchar *details);

	/**
	* ianjuta_message_view_clear:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Clear all messages in buffer
	*/
	void clear ();

	/**
	* ianjuta_message_view_select_next:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Select next message (of type INFO, WARNING or ERROR)
	*/
	void select_next ();

	/**
	* ianjuta_message_view_select_previous:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Select previous message
	*/
	void select_previous ();

	/**
	* ianjuta_message_view_get_current_message:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Get the currently selected message
	*/
	const gchar* get_current_message ();

	/**
	 * ianjuta_message_view_get_all_messages:
	 * @obj: Self
	 * @err: Error propagation and reporting.
	 *
	 * Get a list of all messages. The list has to be freed
	 * Returns: (element-type utf8):
	 */
	List<const gchar*> get_all_messages ();
}

/**
 * SECTION:ianjuta-message-manager
 * @title: IAnjutaMessageManager
 * @short_description: The plugin that managers all message views
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-message-manager.h
 *
 */
interface IAnjutaMessageManager
{
	#include "ianjuta-message-view.h"
	#include <gdk/gdk.h>

	enum Error
	{
		DOESNT_EXIST
	}
	/**
	 * ianjuta_message_manager_add_view:
	 * @obj: Self
	 * @name: Name/Title of the new view
	 * @icon: Path to an icon or ""
	 * @err: Error propagation and reporting
	 *
	 * Adds a new view to the message-manager
	 *
	 * Return value: The new message-view
	 */
	IAnjutaMessageView* add_view (const gchar *name, const gchar *icon);

	/**
	 * ianjuta_message_manager_remove_view:
	 * @obj: Self
	 * @view: The view to remove
	 * @err: Error propagation and reporting
	 *
	 * Remove view from the message-manager. The view
	 * will become invalid.
	 */
	void remove_view (IAnjutaMessageView *view);

	/**
	 * ianjuta_message_manager_get_current_view:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get the view with is currently on top of
	 * the notebook or NULL if the message-manager is empty.
	 *
	 * Return value: Current view; #IAnjutaMessageView object.
	 * NULL, if there is no views.
	 */
	IAnjutaMessageView* get_current_view ();

	/**
	 * ianjuta_message_manager_get_view_by_name:
	 * @obj: Self
	 * @name: Name/Title of the view
	 * @err: Error propagation and reporting
	 *
	 * Get the view with the given name or NULL if
	 * it does not exist.
	 *
	 * Return value: The message-view or NULL
	 */
	IAnjutaMessageView* get_view_by_name (const gchar *name);

	/**
	 * ianjuta_message_manager_get_all_views:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get all message-views
	 *
	 * Return value: (element-type IAnjutaMessageView): A GList* of all views. You must not
	 * manipulate the list.
	 */
	List<IAnjutaMessageView*> get_all_views ();

	/**
	 * ianjuta_message_manager_set_current_view:
	 * @obj: Self
	 * @view: A message view
	 * @err: Error propagation and reporting
	 *
	 * Set view to be on top of the notebook.
	 *
	 */
	void set_current_view (IAnjutaMessageView *view);

	/**
	 * ianjuta_message_manager_set_view_title:
	 * @obj: Self
	 * @view: A message view
	 * @title: Sets the title of view.
	 * @err: Error propagation and reporting
	 *
	 * Sets the title of view.
	 *
	 */
	void set_view_title (IAnjutaMessageView *view, const gchar *title);

	/**
	 * ianjuta_message_manager_set_view_icon:
	 * @obj: Self
	 * @view: A message view
	 * @icon: Sets the icon of view.
	 * @err: Error propagation and reporting
	 *
	 * Sets the icon of view.
	 *
	 */
	void set_view_icon (IAnjutaMessageView *view, GdkPixbufAnimation *icon);

	/**
	 * ianjuta_message_manager_set_view_icon_from_stock:
	 * @obj: Self
	 * @view: A message view
	 * @icon: Sets the icon of view.
	 * @err: Error propagation and reporting
	 *
	 * Sets the icon of view.
	 *
	 */
	void set_view_icon_from_stock (IAnjutaMessageView *view, const gchar *icon);
}

/**
 * SECTION:ianjuta-file-manager
 * @title: IAnjutaFileManager
 * @short_description: File manager plugin
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-file-manager.h
 *
 */
interface IAnjutaFileManager
{
	#include <gio/gio.h>

	/**
	* IANJUTA_FILE_MANAGER_SELECTED_FILE
	*
	* Anjuta shell value set by file manager to the selected file.
	*/
	#define SELECTED_FILE		"file_manager_selected_file"

	/**
	* IAnjutaFileManager::section-changed:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* fixme
	*/
	void ::section_changed (GFile* file);

	/**
	* ianjuta_file_manager_set_root:
	* @obj: Self
	* @root_uri: fixme
	* @err: Error propagation and reporting.
	*
	* fixme
	*/
	void set_root (const gchar *root_uri);

	/**
	* ianjuta_file_manager_get_selected:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* fixme
	*/
	GFile* get_selected ();

	/**
	* ianjuta_file_manager_set_selected:
	* @obj: Self
	* @file: File to select
	* @err: Error propagation and reporting.
	*
	* fixme.
	*/
	void set_selected (GFile* file);
}

/**
 * SECTION:ianjuta-terminal
 * @title: IAnjutaTerminal
 * @short_description: Interface for command line terminals
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-terminal.h
 *
 */
interface IAnjutaTerminal
{
	#include <sys/types.h>

	/**
	* IAnjutaTerminal::child_exited:
	* @obj: Self
	* @pid: pid of terminated child
	* @status: status of terminated child as returned by waitpid
	*
	* This signal is emitted when a child exit.
	*/
	void ::child_exited (gint pid, gint status);


	/**
	* ianjuta_terminal_execute_command:
	* @obj: Self
	* @directory: Working directory
	* @command: Command executed followed by arguments
	* @environment: List of additional environment variables
	* @err: Error propagation and reporting.
	*
	* Run the command in a terminal, setting the working directory
	* and environment variables.
	*
	* Returns: Process ID
	*/
	pid_t execute_command (const gchar* directory, const gchar *command, gchar **environment);
}

/**
 * SECTION:ianjuta-project
 * @title: IAnjutaProject
 * @short_description: Interface implemented by project backend
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-project-backend.h
 *
 * This is the new interface that is replacing Gnome Build.
 */
interface IAnjutaProject
{
	#include <libanjuta/anjuta-project.h>
	#include <gtk/gtk.h>

	/* Types */
	enum Error
	{
		ERROR_SUCCESS = 0,
		ERROR_DOESNT_EXIST,
		ERROR_ALREADY_EXISTS,
		ERROR_VALIDATION_FAILED,
		ERROR_PROJECT_MALFORMED,
		ERROR_WRONG_PARENT,
		ERROR_NOT_SUPPORTED,
		ERROR_GENERAL_FAILURE
	}

	enum Probe
		PROBE_FILES = 10,
		PROBE_MAKE_FILES = 100,
		PROBE_PROJECT_FILES = 200
	}

	/* Signals */

	/**
	* IAnjutaProject::file-changed:
	* @obj: Self
	* @node: Node to be reloaded.
	*
	* This signal is emitted when the project is changed on the disk. The
	* corresponding node has to be reloaded.
	*/
	void ::file_changed (gpointer node);

	/**
	* IAnjutaProject::node-changed:
	* @obj: Self
	* @node: Changed node.
    * @error: Error while changing node
	*
	* This signal is emitted when a node is changed by a function of this
	* interface. The error argument is not NULL if the change was not
 	* possible. The corresponding node need to be saved.
	*/
	void ::node_changed (gpointer node, GError *error);

	/**
	* IAnjutaProject::node-saved:
	* @obj: Self
	* @node: Saved node.
    * @error: Error while saving node
	*
	* This signal is emitted when a node is saved. It returns an error if the
 	* save operation fail.
	*/
	void ::node_saved (gpointer node, GError *error);

	/**
	* IAnjutaProject::node-loaded:
	* @obj: Self
	* @node: Loaded node.
    * @error: Error while loading node
	*
	* This signal is emitted when a node is loaded. It returns an error if the
 	* load operation fail.
	*/
	void ::node_loaded (gpointer node, GError *error);


	/**
	 * ianjuta_project_load_node:
	 * @obj: Self
	 * @node: (transfer none): Project node to reload
	 * @err: Error propagation and reporting
	 *
	 * Reload a project node
	 *
	 * Return value: TRUE if the node has been loaded without error
	 */
	gboolean load_node (AnjutaProjectNode *node);

	/**
	 * ianjuta_project_save_node:
	 * @obj: Self
	 * @node: (transfer none): Project node to save
	 * @err: Error propagation and reporting
	 *
	 * Save a project node
	 *
	 * Return value: TRUE if the node has been saved without error
	 */
	gboolean save_node (AnjutaProjectNode *node);

	/**
	 * ianjuta_project_add_node_after:
	 * @obj: Self
	 * @parent: (transfer none): Parent
	 * @sibling: (allow-none) (transfer none): Sibling
	 * @type: Node type
	 * @file: (allow-none) (transfer none): Optional file object for the node
	 * @name: (allow-none) (transfer none): Optional name for the node
	 * @err: Error propagation and reporting
	 *
	 * Create a new node and insert it after sibling
	 *
	 * Return value: (transfer none): The new node, NULL if error
	 */
	AnjutaProjectNode *add_node_after (AnjutaProjectNode *parent, AnjutaProjectNode *sibling, AnjutaProjectNodeType type, GFile *file, const gchar *name);

	/**
	 * ianjuta_project_add_node_before:
	 * @obj: Self
	 * @parent: (transfer none): Parent
	 * @sibling: (allow-none) (transfer none): Sibling
	 * @type: Node type
	 * @file: (allow-none) (transfer none): Optional file object for the node
	 * @name: (allow-none) (transfer none): Optional name for the node
	 * @err: Error propagation and reporting
	 *
	 * Create a new node and insert it before sibling
	 *
	 * Return value: (transfer none): The new node, NULL if error
	 */
	AnjutaProjectNode *add_node_before (AnjutaProjectNode *parent, AnjutaProjectNode *sibling, AnjutaProjectNodeType type, GFile *file, const gchar *name);

	/**
	 * ianjuta_project_remove_node:
	 * @obj: Self
	 * @node: (transfer none): Node
	 * @err: Error propagation and reporting
	 *
	 * Remove a node
	 *
	 * Return value: TRUE if the node can be removed
	 */
	gboolean remove_node (AnjutaProjectNode *node);

	/**
	 * ianjuta_project_set_property:
	 * @obj: Self
	 * @node: (transfer none): Node
	 * @id: (transfer none): Property
	 * @name: (allow-none) (transfer none): Name for map property
	 * @value: (transfer none): Value
	 * @err: Error propagation and reporting
	 *
	 * Change a properties on node.
	 *
	 * Return value: (allow-none) (transfer none): The new property of NULL if the property cannot be set
	 */
	AnjutaProjectProperty *set_property (AnjutaProjectNode *parent, const gchar *id, const gchar *name, const gchar *value);

	/**
	 * ianjuta_project_remove_property:
	 * @obj: Self
	 * @node: (transfer none): Node
	 * @id: (transfer none): Property
	 * @name: (allow-none) (transfer none): Name for map property
	 * @err: Error propagation and reporting
	 *
	 * Remove a property of the node
	 *
	 * Return value: TRUE if the node is removed
	 */
	gboolean remove_property (AnjutaProjectNode *node, const gchar *id, const gchar *name);

	/**
	 * ianjuta_project_get_root:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Get root_node
	 *
	 * Return value: (transfer none): The root node
	 */
	AnjutaProjectNode *get_root ();

	/**
	 * ianjuta_project_get_node_info:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Return a list of possible node;
	 *
	 * Return value: (element-type Anjuta.ProjectNodeInfo) (transfer none): A list
	 * containing information on all node supported by the project.
	 */
	const List<AnjutaProjectNodeInfo *> get_node_info();

	/**
	 * ianjuta_project_is_loaded:
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Return TRUE if the project is loaded;
	 *
	 * Return value: TRUE if the project is completely loaded.
	 */
	 gboolean is_loaded ();
}

/**
 * SECTION:ianjuta-project-backend
 * @title: IAnjutaProjectBackend
 * @short_description: Interface for creating new project
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-project-backend.h
 *
 */
interface IAnjutaProjectBackend
{
	#include "ianjuta-project.h"

	/**
	 * ianjuta_project_backend_new_project:
	 * @obj: Self
	 * @file: (transfer none): Project file or directory
	 * @err: Error propagation and reporting
	 *
	 * Create a new Anjuta project.
	 *
	 * Return value: (transfer full): An object implementing the
	 * #IAnjutaProject interface.
	 */
	IAnjutaProject* new_project (GFile *file);


	/**
	 * ianjuta_project_backend_probe:
	 * @obj: Self
	 * @file: (transfer none): Project file or directory
	 * @err: Error propagation and reporting
	 *
	 * Check if the directory contains a project supported by this
	 * backend.
	 *
	 * Return value: 0 if the project is invalid and > 0 if the project is
	 * valid.
	 */
	gint probe (GFile *directory);
}

/**
 * SECTION:ianjuta-project-manager
 * @title: IAnjutaProjectManager
 * @short_description: Interface for project managers
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-project-manager.h
 *
 */
interface IAnjutaProjectManager
{

	#include <libanjuta/anjuta-project.h>
	#include <libanjuta/interfaces/ianjuta-project.h>

	/**
	* IANJUTA_PROJECT_MANAGER_PROJECT_ROOT_URI
	*
	* Anjuta shell value set by project manager to the project root uri.
	*/
	#define PROJECT_ROOT_URI	"project_root_uri"

	/**
	* IANJUTA_PROJECT_MANAGER_CURRENT_PROJECT
	*
	* Anjuta shell value set by project manager to the current project object
	* which implement #IAnjutaProject interface.
	*/
	#define CURRENT_PROJECT	"project_manager_current_project"

	/**
	* IANJUTA_PROJECT_MANAGER_CURRENT_URI
	*
	* Anjuta shell value set by project manager to the current uri.
	*/
	#define CURRENT_URI		"project_manager_current_uri"

	// Signals

	/**
	* IAnjutaProjectManager::project_loaded:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Emitted when the project is fully loaded. It can takes a quite long
	* time if the project is big. The project is loaded in several parts
	* in a thread. All functions are available before having the project
	* fully loaded.
	*/
	void ::project_loaded (GError *error);

	/**
	* IAnjutaProjectManager::element_added:
	* @obj: Self
	* @element: A #GFile corrresponding to added element
	* @err: Error propagation and reporting.
	*
	* Emitted when a new element is added to the project. It can be
	* a source, a target or a group. It does not always correspond
	* to an existing file. This signal can be emitted several time for
	* the same element.
	*/
	void ::element_added (GFile *element);

	/**
	* IAnjutaProjectManager::element_removed:
	* @obj: Self
	* @element: A #GFile corresponding to removed element
	* @err: Error propagation and reporting.
	*
	* Emitted when an element is removed from a project. It can be
	* a source, a target or a group.
	*/
	void ::element_removed (GFile *element);

	/**
	* IAnjutaProjectManager::element_selected:
	* @obj: Self
	* @element_uri: A #GFile corresponding to selected element
	* @err: Error propagation and reporting.
	*
	* Emitted when an element is selected in the project view. It
	* can be a source, a target or a group.
	*/
	void ::element_selected (GFile *element);

	// Methods

	/**
	 * ianjuta_project_manager_get_elements:
	 * @obj: Self
	 * @element_type: Select one element type: source, group or target
	 * @err: Error propagation and reporting.
	 *
	 * Get a list of all elements of this type in the project.
	 *
	 * Returns: (element-type GFile) (transfer full): Get list of #GFile corresponding to
	 * all valid elements or %NULL if there are no elements of this type. Free the returned
	 * list with g_list_free() and the files with g_object_unref().
	 */
	List<GFile *> get_elements (AnjutaProjectNodeType element_type);

	/**
	* ianjuta_project_manager_get_target_type:
	* @obj: Self
	* @target: A #GFile corresponding to a target
	* @err: Error propagation and reporting.
	*
	* Get the type of the corresponding target: program, library...
	*
	* Returns: Return the type of the target.
	*/
	AnjutaProjectNodeType get_target_type (GFile *target);

	/**
	 * ianjuta_project_manager_get_targets:
	 * @obj: Self
	 * @target_type: type of the target
	 * @err: Error propagation and reporting.
	 *
	 * Get a list of targets in the project with the corresponding type.
	 *
	 * Returns: (element-type GFile) (transfer full): A list of #GFile corresponding to
	 * each target of the requested type or %NULL if none exists. Free the returned list
	 * with g_list_free() and the files with g_object_unref().
	 */
	List<GFile *> get_targets (AnjutaProjectNodeType target_type);

	/**
	* ianjuta_project_manager_get_parent:
	* @obj: Self
	* @element: A #GFile corresponding to one child.
	* @err: Error propagation and reporting.
	*
	* Gets the parent of the corresponding child.
	*
	* Returns: The parent of the child, or %NULL if the element is the root.
	*/
	GFile* get_parent (GFile *element);

	/**
	 * ianjuta_project_manager_get_children:
	 * @obj: Self
	 * @parent: A #GFile corresponding to the parent.
	 * @children_type: Select one element type: source, group or target
	 * @err: Error propagation and reporting.
	 *
	 * Recursively gets the list of all children below the corresponding
	 * parent having the specify type.
	 *
	 * Returns: (element-type GFile) (transfer full): The list of #GFile
	 * corresponding to all children or %NULL if the element has no
	 * children with the corresponding type. Free the returned * list
	 * with g_list_free() and the files with g_object_unref().
	 */
	List<GFile*> get_children (GFile *parent, gint children_type);

	/**
	 * ianjuta_project_manager_get_selected:
	 * @obj: Self
	 * @err: Error propagation and reporting.
	 *
	 * Gets the currently selected element in the project manager view.
	 *
	 * Returns: (transfer full): A #GFile corresponding to the selected element in the project
	 * view. You own the returned file; use g_object_unref() to release it.
	 */
	GFile* get_selected ();

	/**
	* ianjuta_project_manager_get_capabilities:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Gets the capabilites of project whether it can add group, target
	* sources etc.
	*
	* Returns: Supported capabilites.
	*/
	guint get_capabilities ();

	/**
	 * ianjuta_project_manager_add_source:
	 * @obj: Self.
	 * @name: Source name or URI.
	 * @default_target: (allow-none): A #GFile corresponding to the default target or group or
	 *					%NULL if you don't care.
	 * @err: Error propagation and reporting.
	 *
	 * Prompts the user to add a file to the project. If the user selects
	 * multiple files only the first source file is returned.
	 *
	 * You can add non existing file. In this case the element_added
	 * signal will be emitted with a non existing file. So it is
	 * up to the caller to reemit this signal later when the file
	 * is created.
	 *
	 * Returns: (transfer full): A #GFile corresponding to the new source file in the
	 * project view. You own the returned file; use g_object_unref() to release it.
	 */
	GFile* add_source (const gchar *name, GFile *default_target);

	/**
	 * ianjuta_project_manager_add_source_quiet:
	 * @obj: Self.
	 * @name: Source name or URI.
	 * @target: A #GFile corresponding to the parent target or group.
	 * @err: Error propagation and reporting.
	 *
	 * Adds a file to the project without prompting the user.
	 *
	 * You can add non existing file. In this case the element_added
	 * signal will be emitted with a non existing file. So it is
	 * up to the caller to reemit this signal later when the file
	 * is created.
	 *
	 * Returns: (transfer full): A #GFile corresponding to the new source file in the project
	 * view. You own the returned file; use g_object_unref() to release it.
	 */
	GFile* add_source_quiet (const gchar *name, GFile *target);

	/**
	 * ianjuta_project_manager_add_sources:
	 * @obj: Self.
	 * @names: (element-type utf8): Sources name or URI to add.
	 * @default_target: (allow-none): A #GFile corresponding to the default target or group or
	 *					%NULL if don't care.
	 * @err: Error propagation and reporting.
	 *
	 * Prompts the user to add several files to the project. Depending on the
	 * project backend, it can be possible that the source files must
	 * be located in a particular directory.
	 *
	 * You can add non existing file. In this case the element_added
	 * signal will be emitted with a non existing file. So it is
	 * up to the caller to reemit this signal later when the file
	 * is created.
	 *
	 * Returns: (element-type GFile) (transfer full): A list of #GFile corresponding to all
	 * new source files added in the project. You own the list with the the returned files;
	 * use g_list_free() and g_object_unref() on each file to release them.
	 */
	List<GFile*> add_sources (List<const gchar*> names, GFile *default_target);

	/**
	 * ianjuta_project_manager_add_target:
	 * @obj: Self
	 * @name: Target name or URI.
	 * @default_group: (allow-none): A #GFile corresponding to the default parent group or
	 *					%NULL if don't care.
	 * @err: Error propagation and reporting.
	 *
	 * Prompts the user to add a new target to the project. The user can select
	 * a parent group different from the one set as default.
	 *
	 * Returns: (transfer full): A #GFile corresponding to the new target added in the project.
	 * You own the returned file; use g_object_unref() to release it.
	 */
	GFile* add_target (const gchar *name, GFile *default_group);

	/**
	 * ianjuta_project_manager_add_group:
	 * @obj: Self.
	 * @name: Group name or URI.
	 * @default_group: (allow-none): A #GFile corresponding to the default parent group or
	 *					%NULL if don't care.
	 * @err: Error propagation and reporting.
	 *
	 * Prompts the user to add a new group to the project. The user can select
	 * a parent group different from the one set as default.
	 *
	 * Returns: (transfer full): A #GFile corresponding to the new group added in the project.
	 * You own the returned file; use g_object_unref() to release it.
	 */
	GFile* add_group (const gchar *name, GFile *default_group);

	/**
	* ianjuta_project_manager_is_open:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Gets whether a project is currently opened.
	*
	* Returns: %TRUE if a project is opened.
	*/
	gboolean is_open ();

	/**
	 * ianjuta_project_manager_get_packages:
	 * @obj: Self
	 * @err: Error propagation and reporting.
	 *
	 * Returns: (element-type utf8) (transfer container): the list of pkg-config packages that the current project
	 * requires in it's configure.ac. Can be NULL if there is no project
	 * opened currently or no package is required.
	 */
	List<gchar*> get_packages();

	/**
	 * ianjuta_project_manager_get_current_project:
	 * @obj: Self
	 * @err: Error propagation and reporting.
	 *
	 * Gets the current project.
	 *
	 * Return value: (transfer none): the currently active project. NULL if none is there.
	 */
	IAnjutaProject* get_current_project ();
}

/**
 * SECTION:ianjuta-project-chooser
 * @title: IAnjutaProjectChooser
 * @short_description: Interface for selecting project node
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-project-chooser.h
 *
 */
interface IAnjutaProjectChooser
{

	#include <libanjuta/anjuta-project.h>
	#include <libanjuta/interfaces/ianjuta-project-manager.h>

	// Signals

	/**
	* IAnjutaProjectChooser::changed:
	* @obj: Self
	*
	* Emitted when the selected node is changed.
	*/
	void ::changed ();

	// Methods

	/**
	 * ianjuta_project_chooser_set_project_model:
	 * @obj: Self
	 * @manager: A project manager
	 * @child_type: Select one element type: source, group or target
	 * @err: Error propagation and reporting.
	 *
	 * Initialize a project chooser button allowing to select a parent node
	 * where you can add the nodes of type child_type.
	 * As special cases with
	 * <variablelist>
	 *   <varlistentry>
	 *     <term>ANJUTA_PROJECT_ROOT</term>
	 *     <listitem><para>all nodes are included</para></listitem>
	 *   </varlistentry>
	 *   <varlistentry>
	 *     <term>ANJUTA_PROJECT_MODULE</term>
	 *     <listitem><para>only modules are included, this can be used
	 *     to add a new package. While ANJUTA_PROJECT_PACKAGE allows you
	 *     to select a target using a package.</para></listitem>
	 *   </varlistentry>
	 * </variablelist>
	 *
	 * Returns: TRUE if sucessful, other FALSE.
	 */
	gboolean set_project_model (IAnjutaProjectManager *manager, AnjutaProjectNodeType child_type);


	/**
	 * ianjuta_project_chooser_get_selected:
	 * @obj: Self
	 * @err: Error propagation and reporting.
	 *
	 * Gets the currently selected element in the project chooser.
	 *
	 * Returns: (transfer none): A #GFile corresponding to the selected
	 * element in the project view or %NULL if no valid node is selected.
	 * The file is owned by the widget If you want to keep a pointer to
	 * the file you must add a refcount using g_object_ref().
	 */
	GFile* get_selected ();
}


/**
 * SECTION:ianjuta-todo
 * @title: IAnjutaTodo
 * @short_description: Task manager interface
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-todo.h
 *
 */
interface IAnjutaTodo
{
	#include <gio/gio.h>
	/**
	* ianjuta_to_do_load:
	* @obj: Self
	* @file: fixme
	* @err: Error propagation and reporting.
	*
	* fixme
	*/
	void load(GFile *file);
}

/**
 * SECTION:ianjuta-wizard
 * @title: IAnjutaWizard
 * @short_description: Interface for wizards that can create new stuffs
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-wizard.h
 *
 */
interface IAnjutaWizard
{

	/**
	* ianjuta_wizard_activate:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Called when the wizard should start after some user action
	*/
	void activate();
}

/**
 * SECTION:ianjuta-debugger
 * @title: IAnjutaDebugger
 * @short_description: Debugger interface
 * @see_also: #IAnjutaDebugManager
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-debugger.h
 *
 * This interface is implemented by debugger backends, by example the gdb
 * backend. It is used by the debug manager plugin which provides the
 * graphical interface and a simple wrapper: #IAnjutaDebugManager.
 *
 * The debugger is in one on these 5 states and emit a signal to the debug
 * manager when it changes. Here is figure showing all transitions and
 * the signal emitted.
 * <figure id="debugger-states">
 *	<mediaobject>
 *		<imageobject>
 *			<imagedata fileref="debugger-states.png" format="PNG"/>
 *		</imageobject>
 *	</mediaobject>
 * </figure>
 *
 */
interface IAnjutaDebugger
{
	#include "ianjuta-message-view.h"
	#include <sys/types.h>
	#include <gio/gio.h>

	/* Types */
	/**
	 * IAnjutaDebuggerError:
	 * @IANJUTA_DEBUGGER_OK: No error
	 * @IANJUTA_DEBUGGER_NOT_READY: Debugger is not ready to execute the command
	 * @IANJUTA_DEBUGGER_NOT_RUNNING: Debugger is not is running state
	 * @IANJUTA_DEBUGGER_NOT_STOPPED: Debugger is not is stopped state
	 * @IANJUTA_DEBUGGER_NOT_LOADED: Debugger is not is loaded state
	 * @IANJUTA_DEBUGGER_NOT_STARTED: Debugger is not in started state
	 * @IANJUTA_DEBUGGER_NOT_CONNECTED: Debugger is not connected:
	 * @IANJUTA_DEBUGGER_NOT_IMPLEMENTED: Corresponding function is not implemented
	 * @IANJUTA_DEBUGGER_CANCEL: Operation has been cancelled
	 * @IANJUTA_DEBUGGER_UNABLE_TO_CREATE_VARIABLE: Debugger cannot create variable
	 * @IANJUTA_DEBUGGER_UNABLE_TO_ACCESS_MEMORY: Debugger cannot access memory
	 * @IANJUTA_DEBUGGER_UNABLE_TO_OPEN_FILE: Debugger cannot open file
	 * @IANJUTA_DEBUGGER_UNSUPPORTED_FILE_TYPE: Debugger cannot debug such file
	 * @IANJUTA_DEBUGGER_UNSUPPORTED_VERSION: Debugger is too old
	 * @IANJUTA_DEBUGGER_UNABLE_TO_FIND_DEBUGGER: Debugger cannot be found
	 * @IANJUTA_DEBUGGER_ALREADY_DONE: Command has already been executed
	 * @IANJUTA_DEBUGGER_PROGRAM_NOT_FOUND: Program cannot be found
	 * @IANJUTA_DEBUGGER_UNABLE_TO_CONNECT: Unable to connect to debugger
	 * @IANJUTA_DEBUGGER_UNKNOWN_ERROR: Unknown error
	 * @IANJUTA_DEBUGGER_OTHER_ERROR: other error
	 *
	 * This enumeration is used to defined the error returned by the debugger
	 * backend.
	 */
	enum Error
	{
		OK              =  0,
		NOT_READY,
		NOT_RUNNING,
		NOT_STOPPED,
		NOT_LOADED,
		NOT_STARTED,
		NOT_CONNECTED,
		NOT_IMPLEMENTED,
		CANCEL,
		UNABLE_TO_CREATE_VARIABLE,
		UNABLE_TO_ACCESS_MEMORY,
		UNABLE_TO_OPEN_FILE,
		UNSUPPORTED_FILE_TYPE,
		UNSUPPORTED_VERSION,
		UNABLE_TO_FIND_DEBUGGER,
		ALREADY_DONE,
		PROGRAM_NOT_FOUND,
		UNABLE_TO_CONNECT,
		UNKNOWN_ERROR,
		OTHER_ERROR
	}

	/**
	 * IAnjutaDebuggerOutputType:
	 * @IANJUTA_DEBUGGER_OUTPUT: Output from debugger
	 * @IANJUTA_DEBUGGER_WARNING_OUTPUT: Warning from debugger
	 * @IANJUTA_DEBUGGER_ERROR_OUTPUT: Error from debugger
	 * @IANJUTA_DEBUGGER_INFO_OUTPUT: Additional message from debugger
	 *
	 * This enumeration is used to defined the kind of output in
	 * #IAnjutaDebuggerOutputCallback
	 */
	enum OutputType
	{
		OUTPUT,
		WARNING_OUTPUT,
		ERROR_OUTPUT,
		INFO_OUTPUT
	}

	/**
	 * IAnjutaDebuggerState:
	 * @IANJUTA_DEBUGGER_BUSY: Debugger is executing a command, it can enter in another
	 *                         at the end of the command.
	 * @IANJUTA_DEBUGGER_STOPPED: Debugger is stopped.
	 * @IANJUTA_DEBUGGER_STARTED: Debugger is started but no program is loaded.
	 * @IANJUTA_DEBUGGER_PROGRAM_LOADED: Debugger is started and has a program loaded.
	 * @IANJUTA_DEBUGGER_PROGRAM_STOPPED: Debugger is started and has a program stopped.
	 * @IANJUTA_DEBUGGER_PROGRAM_RUNNING: Debugger is started and has a program running.
	 *
	 * This enumeration is used to defined the different state of the debugger.
	 */
	enum State
	{
		BUSY,
		STOPPED,
		STARTED,
		PROGRAM_LOADED,
		PROGRAM_STOPPED,
		PROGRAM_RUNNING
	}

	/**
	 * IAnjutaDebuggerFrame:
	 * @thread: Thread identifier.
	 * @level: Level of the frame, 0 is the topmost one.
	 * @args: List of argument of the caller.
	 * @file: Source file name where is the program counter.
	 * @line: Line number in the file above.
	 * @function: Function name where is the program counter.
	 * @library: Library name where is the program counter.
	 * @address: Address of the program counter.
	 *
	 * This structure keeps all information about a stack frame.
	 */
	struct Frame
	{
		gint thread;
		guint level;
		gchar *args;
		gchar *file;
		guint line;
		gchar *function;
		gchar *library;
		gulong address;
	}

	/**
	 * IAnjutaDebuggerCallback:
	 * @data: data
	 * @user_data: user data passed to the function
	 * @error: error
	 *
	 * This callback function is used only by #ianjuta_debugger_callback with a
	 * NULL data.
	 */
	typedef void (*Callback) (const gpointer data, gpointer user_data, GError* err);

	/**
	 * IAnjutaDebuggerGListCallback:
	 * @list: (element-type any): list of data
	 * @user_data: user data passed to the function
	 * @error: error
	 *
	 * This callback function is used by several debugger functions. Depending on
	 * the function, the kind of elements in the list is different. It is a string
	 * for #ianjuta_debugger_list_local or a #IAnjutaDebuggerFrame for
	 * #ianjuta_debugger_list_frame.
	 */
	typedef void (*GListCallback) (const GList* list, gpointer user_data, GError* err);

	/**
	 * IAnjutaDebuggerGCharCallback:
	 * @data: string
	 * @user_data: user data
	 * @error: error
	 *
	 * This callback function is used by several debugger functions. The data is
	 * a string
	 */
	typedef void (*GCharCallback) (const gchar *value, gpointer user_data, GError* err);

	/**
	 * IAnjutaDebuggerOutputCallback:
	 * @data: Self
	 * @user_data: user data
	 * @error: error
	 *
	 * This callback function is used only by #ianjuta_debugger_callback with a
	 * NULL data.
	 */
	typedef void (*OutputCallback) (OutputType type, const gchar *output, gpointer user_data);

	/* Signals */

	/**
	* IAnjutaDebugger::debugger_started:
	* @obj: Self
	*
	* This signal is emitted when the debugger is started.
	*/
	void ::debugger_started ();

	/**
	* IAnjutaDebugger::debugger_stopped:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* This signal is emitted when the debugger is stopped. The error
	* parameters allow to check it has run correctly.
	*/
	void ::debugger_stopped (GError *err);

	/**
	* IAnjutaDebugger::program_loaded:
	* @obj: Self
	*
	* This signal is emitted when a program is loaded.
	*/
	void ::program_loaded ();

	/**
	* IAnjutaDebugger::program_running:
	* @obj: Self
	*
	* This signal is emitted when the program is running.
	*/
	void ::program_running ();

	/**
	* IAnjutaDebugger::program_stopped:
	* @obj: Self
	*
	* This signal is emitted when the program is interrupted.
	*/
	void ::program_stopped ();

	/**
	* IAnjutaDebugger::program_exited:
	* @obj: Self
	*
	* This signal is emitted when the program exits.
	*/
	void ::program_exited ();

	/**
	* IAnjutaDebugger::sharedlib_event:
	* @obj: Self
	*
	* This signal is emitted when the program load a new shared
	* library.
	*/
	void ::sharedlib_event ();

	/**
	* IAnjutaDebugger::program_moved:
	* @obj: Self
 	* @pid: process id, 0 when unknown
	* @tid: thread id, 0 when unknown
	* @address: program counter address, 0 when unknown
	* @file: source file where is the program counter, NULL when unknown
	* @line: line number if file name above is not NULL
	*
	* This signal is emitted when the debugger know the current program
	* location. Most of the time, after the program has stopped but it
	* could happen even if it is still running.
	*/
	void ::program_moved (gint pid, gint tid, gulong address, const gchar* file, guint line);

	/**
	* IAnjutaDebugger::frame_changed:
	* @obj: Self
	* @frame: frame number
	* @thread: thread number
	*
	* This signal is emitted when the current frame changes.
	*/
	void ::frame_changed (guint frame, gint thread);

	/**
	* IAnjutaDebugger::signal_received:
	* @obj: Self
	* @name: Signal name
	* @description: Signal description
	*
	* This signal is emitted when the program received a unix signal.
	*/
	void ::signal_received (const gchar* name, const gchar* description);

	/**
	* IAnjutaDebugger::debugger_ready:
	* @obj: Self
	* @state: debugger status
	*
	* This signal is emitted when the debugger is ready to execute
	* a new command.
	*/
	void ::debugger_ready (State state);


	/**
	* ianjuta_debugger_get_state:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Get the current state of the debugger
	*
	* Returns: The current debugger state.
	*/
	State get_state ();




	/**
	 * ianjuta_debugger_load:
	 * @obj: Self
	 * @file: filename
	 * @mime_type: mime type of the file
	 * @source_search_directories: (element-type utf8): List of directories to search for
	 *			      source files.
	 * @err: Error propagation and reporting.
	 *
	 * Load a program in the debugger.
	 *
	 * Returns: TRUE if sucessful, other FALSE.
	 */
	gboolean load (const gchar *file, const gchar *mime_type, const List<const gchar*> source_search_directories);

	/**
	 * ianjuta_debugger_attach:
	 * @obj: Self
	 * @pid: pid of the process to debug
	 * @source_search_directories: (element-type utf8): List of directories to search for
	 *			      source files.
	 * @err: Error propagation and reporting.
	 *
	 * Attach to an already running process.
	 *
	 * Returns: TRUE if sucessful, other FALSE.
	 */
	gboolean attach (pid_t pid, const List<const gchar*> source_search_directories);

	/**
	* ianjuta_debugger_set_working_directory:
	* @obj: Self
	* @dir: working program directory
	* @err: Error propagation and reporting.
	*
	* Set program working directory.
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean set_working_directory (const gchar *dir);

	/**
	* ianjuta_debugger_set_environment:
	* @obj: Self
	* @env: List environment variable
	* @err: Error propagation and reporting
	*
	* Set environment variable
	*
	* Returns: TRUE if sucessfull, other FALSE.
	*/
	gboolean set_environment (gchar **env);

	/**
	* ianjuta_debugger_start:
	* @obj: Self
	* @args: command line argument of the program
	* @terminal: TRUE if the program need a terminal
	* @stop: TRUE if program is stopped at the beginning
	* @err: Error propagation and reporting.
	*
	* Start a loaded program under debugger control.
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean start (const gchar *args, gboolean terminal, gboolean stop);

	/**
	* ianjuta_debugger_connect:
	* @obj: Self
	* @server: remote server
	* @args: command line argument of the program
	* @terminal: TRUE if the program need a terminal
	* @stop: TRUE if program is stopped at the beginning
	* @err: Error propagation and reporting
	*
	* Connect to a remote debugger and run program
	*
	* Returns: TRUE if sucessfull, otherwise FALSE.
	*/
	gboolean connect (const gchar *server, const gchar *args, gboolean terminal, gboolean stop);

	/**
	* ianjuta_debugger_unload:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Unload a program.
	*
	* Returns: TRUE if sucessfull, otherwise FALSE.
	*/
	gboolean unload ();

	/**
	* ianjuta_debugger_quit:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Quit the debugger, can wait until the debugger is ready.
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean quit ();

	/**
	* ianjuta_debugger_abort:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Quit the debugger as fast as possible.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean abort ();

	/**
	* ianjuta_debugger_run:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Run the program currently loaded.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean run ();

	/**
	* ianjuta_debugger_step_in:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Execute a single C instruction of the program currently loaded.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean step_in ();

	/**
	* ianjuta_debugger_step_over:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Execute one C instruction, without entering in procedure, of
	* the program currently loaded.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean step_over ();

	/**
	* ianjuta_debugger_step_out:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Execute the currently loaded program until it goes out of the
	* current procedure.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean step_out ();

	/**
	* ianjuta_debugger_run_to:
	* @obj: Self
	* @file: target file name
	* @line: target line in file
	* @err: Error propagation and reporting.
	*
	* Execute the currently loaded program until it reachs the target
	* line.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean run_to (const gchar* file, gint line);

	/**
	* ianjuta_debugger_run_from:
	* @obj: Self
	* @file: target file name
	* @line: target line in file
	* @err: Error propagation and reporting.
	*
	* Execute the program from a new position.
	* This function is optional.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean run_from (const gchar *file, gint line);

	/**
	* ianjuta_debugger_exit:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Exit from the currently loaded program.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean exit ();

	/**
	* ianjuta_debugger_interrupt:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Interrupt the program currently running.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean interrupt ();



	/**
	* ianjuta_debugger_inspect:
	* @obj: Self
	* @name: variable name
	* @callback: Callback to call with variable value
	* @user_data: User data that is passed back to the callback
	* @err: Error propagation and reporting.
	*
	* Get back the value of the named variable.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean inspect (const gchar* name, GCharCallback callback, gpointer user_data);

	/**
	* ianjuta_debugger_evaluate:
	* @obj: Self
	* @name: variable name
	* @value: new variable value
	* @callback: Callback to call when the variable has been modified
	* @user_data: User data that is passed back to the callback
	* @err: Error propagation and reporting.
	*
	* Change the value of a variable in the current program.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean evaluate (const gchar* name, const gchar* value, GCharCallback callback, gpointer user_data);

	/**
	* ianjuta_debugger_print:
	* @obj: Self
	* @name: variable name
	* @callback: Callback to call with variable value
	* @user_data: User data that is passed back to the callback
	* @err: Error propagation and reporting.
	*
	* Display value of a variable, like inspect.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean print (const gchar *variable, GCharCallback callback, gpointer user_data);

	/**
	* ianjuta_debugger_list_local:
	* @obj: Self
	* @callback: Callback to call with list of local variable
	* @user_data: User data that is passed back to the callback
	* @err: Error propagation and reporting.
	*
	* Get the list of local variables
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean list_local (GListCallback callback, gpointer user_data);

	/**
	* ianjuta_debugger_list_argument:
	* @obj: Self
	* @callback: Callback to call with list of arguments
	* @user_data: User data that is passed back to the callback
	* @err: Error propagation and reporting.
	*
	* Get the list of arguments
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean list_argument (GListCallback callback, gpointer user_data);

	/**
	* ianjuta_debugger_info_signal:
	* @obj: Self
	* @callback: Callback to call with list of arguments
	* @user_data: User data that is passed back to the callback
	* @err: Error propagation and reporting.
	*
	* Get some informatin about a signal
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean info_signal (GListCallback callback, gpointer user_data);

	/**
	* ianjuta_debugger_info_sharedlib:
	* @obj: Self
	* @callback: Callback to call with list of arguments
	* @user_data: User data that is passed back to the callback
	* @err: Error propagation and reporting.
	*
	* Get information about shared libraries.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean info_sharedlib (GListCallback callback, gpointer user_data);

	/**
	* ianjuta_debugger_handle_signal:
	* @obj: Self
	* @name: signal name
	* @stop: TRUE if we need to stop signal
	* @print: TRUE if we display a message when the signal is emitted
	* @ignore: TRUE if we ignore the signal
	* @err: Error propagation and reporting.
	*
	* It defines how to handle signal received by the program.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean handle_signal (const gchar *name, gboolean stop, gboolean print, gboolean ignore);

	/**
	* ianjuta_debugger_info_frame:
	* @obj: Self
	* @frame: frame number, the top frame has the number 0
	* @callback: Callback to call getting a list of strings with all information
	* @user_data: User data that is passed back to the callback
	* @err: Error propagation and reporting.
	*
	* Get some information about the one stack frame.
	* This function has been deprecated and is not used anymore in the
	* debugger GUI.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean info_frame (guint frame, GListCallback callback, gpointer user_data);

	/**
	* ianjuta_debugger_info_args:
	* @obj: Self
	* @callback: Callback to call getting a list of strings with all information
	* @user_data: User data that is passed back to the callback
	* @err: Error propagation and reporting.
	*
	* Get some informatin about a current functin arguments.
	* This function has been deprecated and is not used anymore in the
	* debugger GUI.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean info_args (GListCallback callback, gpointer user_data);

	/**
	* ianjuta_debugger_info_target:
	* @obj: Self
	* @callback: Callback to call getting a list of strings with all information
	* @user_data: User data that is passed back to the callback
	* @err: Error propagation and reporting.
	*
	* Get back some information about the target
	* This function has been deprecated and is not used anymore in the
	* debugger GUI.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean info_target (GListCallback callback, gpointer user_data);

	/**
	* ianjuta_debugger_info_program:
	* @obj: Self
	* @callback: Callback to call getting a list of strings with all information
	* @user_data: User data that is passed back to the callback
	* @err: Error propagation and reporting.
	*
	* Get some informatin about a current program.
	* This function has been deprecated and is not used anymore in the
	* debugger GUI.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean info_program (GListCallback callback, gpointer user_data);

	/**
	* ianjuta_debugger_info_udot:
	* @obj: Self
	* @callback: Callback to call getting a list of strings with all information
	* @user_data: User data that is passed back to the callback
	* @err: Error propagation and reporting.
	*
	* Get some informatin about OS structures.
	* This function has been deprecated and is not used anymore in the
	* debugger GUI.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean info_udot (GListCallback callback, gpointer user_data);


	/**
	* ianjuta_debugger_info_variables:
	* @obj: Self
	* @callback: Callback to call getting a list of strings with all information
	* @user_data: User data that is passed back to the callback
	* @err: Error propagation and reporting.
	*
	* Get some informatin about variables.
	* This function has been deprecated and is not used anymore in the
	* debugger GUI.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean info_variables (GListCallback callback, gpointer user_data);

	/**
	* ianjuta_debugger_list_frame:
	* @obj: Self
	* @callback: Callback to call getting a list of #IAnjutaDebuggerFrame
	* @user_data: User data that is passed back to the callback
	* @err: Error propagation and reporting.
	*
	* Get the list of frames.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean list_frame (GListCallback callback, gpointer user_data);

	/**
	* ianjuta_debugger_set_frame:
	* @obj: Self
	* @frame: frame number
	* @err: Error propagation and reporting.
	*
	* Set the current frame.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean set_frame (guint frame);

	/**
	* ianjuta_debugger_list_thread:
	* @obj: Self
	* @callback: Callback to call getting a list of #IAnjutaDebuggerFrame for each thread
	* @user_data: User data that is passed back to the callback
	* @err: Error propagation and reporting.
	*
	* Get the list of threads.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean list_thread (GListCallback callback, gpointer user_data);

	/**
	* ianjuta_debugger_set_thread:
	* @obj: Self
	* @thread: thread number
	* @err: Error propagation and reporting.
	*
	* Set the current thread.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean set_thread (gint thread);

	/**
	* ianjuta_debugger_info_thread:
	* @obj: Self
	* @thread: thread number
	* @callback: Callback to call getting a list of strings with all information
	* @user_data: User data that is passed back to the callback
	* @err: Error propagation and reporting.
	*
	* Get some information about current threads.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean info_thread (gint thread, GListCallback callback, gpointer user_data);

	/**
	* ianjuta_debugger_send_command:
	* @obj: Self
	* @command: command
	* @err: Error propagation and reporting.
	*
	* Send a command directly to the debugger. Warning, changing the
	* debugger states, by sending a run command by example, will
	* probably gives some troubles in the debug manager.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean send_command (const gchar *command);

	/**
	* ianjuta_debugger_callback:
	* @obj: Self
	* @callback: Callback to call. the data argument is NULL.
	* @user_data: User data that is passed back to the callback
	* @err: Error propagation and reporting.
	*
	* All commands are executed asynchronously and give back information
	* with callbacks. It is difficult to know when a command is really
	* executed. But as all commands are executed in order, you can use
	* this command to get a call back when all previous commands have
	* been executed.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean callback (Callback callback, gpointer user_data);

	/**
	* ianjuta_debugger_enable_log:
	* @obj: Self
	* @log: MessageView used by log
	* @err: Error propagation and reporting.
	*
	* Log all debuggers commands, mainly useful for debugging.
	*/
	void enable_log (IAnjutaMessageView *log);

	/**
	* ianjuta_debugger_disable_log:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Disable debugger log.
	*/
	void disable_log ();

	/**
	* ianjuta_debugger_dump_stack_trace:
	* @obj: Self
	* @callback: Callback to call getting a list of strings
	* @user_data: User data that is passed back to the callback
	* @err: Error propagation and reporting.
	*
	* Return a stack trace valid for a bug reports.
	* This function is optional.
	*
	* Returns: TRUE if sucessful, otherwise FALSE.
	*/
	gboolean dump_stack_trace (GListCallback callback, gpointer user_data);

	/**
	 * SECTION:ianjuta-debugger-breakpoint
	 * @title: IAnjutaDebuggerBreakpoint
	 * @short_description: Breakpoint Debugger interface
	 * @see_also:
	 * @stability: Unstable
	 * @include: libanjuta/interfaces/ianjuta-debugger-breakpoint.h
	 *
	 */
	interface IAnjutaDebuggerBreakpoint
	{

		/**
		 * IAnjutaDebuggerBreakpointType:
		 * @IANJUTA_DEBUGGER_BREAKPOINT_REMOVED: Set for removed breakpoint
		 * @IANJUTA_DEBUGGER_BREAKPOINT_UPDATED: Set for changed breakpoint
		 * @IANJUTA_DEBUGGER_BREAKPOINT_ON_LINE: Set on source line
		 * @IANJUTA_DEBUGGER_BREAKPOINT_ON_ADDRESS: Set on an addresse
		 * @IANJUTA_DEBUGGER_BREAKPOINT_ON_FUNCTION: Set on a function name
		 * @IANJUTA_DEBUGGER_BREAKPOINT_ON_READ: Set on read access
		 * @IANJUTA_DEBUGGER_BREAKPOINT_ON_WRITE: Set on write access
		 * @IANJUTA_DEBUGGER_BREAKPOINT_WITH_ENABLE: Has enable information
		 * @IANJUTA_DEBUGGER_BREAKPOINT_WITH_IGNORE: Has ignore information,
		 * @IANJUTA_DEBUGGER_BREAKPOINT_WITH_TIME: Has counter information
		 * @IANJUTA_DEBUGGER_BREAKPOINT_WITH_CONDITION: Has a condition
		 * @IANJUTA_DEBUGGER_BREAKPOINT_WITH_TEMPORARY: Temporary breakpoint, automatically removed when triggered
		 * @IANJUTA_DEBUGGER_BREAKPOINT_WITH_PENDING: Pending breakpoint
		 *
		 * This enumeration defined various characteristics of the breakpoint.
		 */
		enum Type
		{
			REMOVED = 1 << 0,
			UPDATED = 1 << 17,
			ON_LINE = 1 << 1,
			ON_ADDRESS = 1 << 2,
			ON_FUNCTION = 1 << 3,
			ON_READ = 1 << 4,
			ON_WRITE = 1 << 5,
			WITH_ENABLE = 1 << 16,
			WITH_IGNORE = 1 << 15,
			WITH_TIME = 1 << 11,
			WITH_CONDITION = 1 << 12,
			WITH_TEMPORARY = 1 << 13,
			WITH_PENDING = 1 << 14,
		}

		/**
		 * IAnjutaDebuggerBreakpointItem:
		 * @type: type see #IAnjutaBreakpointType enumeration
		 * @id: unique identifier
		 * @file: source file where is the breakpoint
		 * @line: corresponding source file line number
		 * @function: corresponding function name
		 * @address: corresponding address
		 * @enable: TRUE if the breakpoint is enabled
		 * @ignore: TRUE if the breakpoint is ignored
		 * @times: Count how many time the breakpoint is triggered
		 * @condition: Additional condition for triggering the breakpoint
		 * @temporary: TRUE if the breakpoint is temporary
		 * @pending: TRUE if the breakpoint is pending
		 *
		 * This structure keeps all information about a breakpoint.
		 */
		struct Item
		{
			gint type;
			guint id;
			gchar *file;
			guint line;
			gchar *function;
			gulong address;
			gboolean enable;
			guint ignore;
			guint times;
			gchar *condition;
			gboolean temporary;
			gboolean pending;
		}

		/**
		 * IAnjutaDebuggerBreakpointMethod:
		 * @IANJUTA_DEBUGGER_BREAKPOINT_SET_AT_ADDRESS: Allow to set breakpoint on address
		 * @IANJUTA_DEBUGGER_BREAKPOINT_SET_AT_FUNCTION: Allow to set breakpoint on function name
		 * @IANJUTA_DEBUGGER_BREAKPOINT_ENABLE: Allow to disable breakpoint
		 * @IANJUTA_DEBUGGER_BREAKPOINT_IGNORE: Allow to ignore breakpoint
		 * @IANJUTA_DEBUGGER_BREAKPOINT_CONDITION: Allow to add a condition on breakpoint
		 *
		 * Defines which breakpoint characteristics are supported by the debugger
		 * backend.
		 */
		enum Method
		{
			SET_AT_ADDRESS = 1 << 0,
			SET_AT_FUNCTION = 1 << 1,
			ENABLE = 1 << 2,
			IGNORE = 1 << 3,
			CONDITION = 1 << 4
		}

		/**
		 * IAnjutaDebuggerBreakpointCallback:
		 * @data: a #IAnjutaBreakpointItem object
		 * @user_data: user data passed to the function
		 * @error: error
		 *
		 * This callback function is used to return a #IAnjutaBreakpointItem.
		 */
		typedef void (*Callback) (const Item *data, gpointer user_data, GError* err);

		/**
		* ianjuta_debugger_breakpoint_implement_breakpoint:
		* @obj: Self
		* @err: Error propagation and reporting.
		*
		* Return all implemented methods.
		*
		* Returns: A OR of #IAnjutaDebuggerBreakpointMethod
		* corresponding to all implemented optional methods.
		*/
		gint implement_breakpoint ();

		/**
		* ianjuta_debugger_breakpoint_set_breakpoint_at_line:
		* @obj: Self
		* @file: File containing the breakpoint
		* @line: Line number where is the breakpoint
		* @callback: Callback to call when the breakpoint has been set
		* @user_data: User data that is passed back to the callback
		* @err: Error propagation and reporting.
		*
		* Set a breakpoint at the specified line in the file.
		*
		* Returns: TRUE if the request succeed and the callback is called. If
		* FALSE, the callback will not be called.
		*/
		gboolean set_breakpoint_at_line (const gchar* file, guint line, Callback callback, gpointer user_data);


		/**
		* ianjuta_debugger_breakpoint_set_breakpoint_at_address:
		* @obj: Self
		* @address: Address of the breakpoint
		* @callback: Callback to call when the breakpoint has been set
		* @user_data: User data that is passed back to the callback
		* @err: Error propagation and reporting.
		*
		* Set a breakpoint at the specified address.
		* This function is optional.
		*
		* Returns: TRUE if the request succeed and the callback is called. If
		* FALSE, the callback will not be called.
		*/
		gboolean set_breakpoint_at_address (gulong address, Callback callback, gpointer user_data);

		/**
		* ianjuta_debugger_breakpoint_set_breakpoint_at_function:
		* @obj: Self
		* @file: File containing the breakpoint
		* @function: Function name where the breakpoint is put
		* @callback: Callback to call when the breakpoint has been set
		* @user_data: User data that is passed back to the callback
		* @err: Error propagation and reporting.
		*
		* Set a breakpoint at the beginning of the specified function.
		* This function is optional.
		*
		* Returns: TRUE if the request succeed and the callback is called. If
		* FALSE, the callback will not be called.
		*/
		gboolean set_breakpoint_at_function (const gchar* file, const gchar* function, Callback callback, gpointer user_data);

		/**
		* ianjuta_debugger_breakpoint_clear_breakpoint:
		* @obj: Self
		* @id: Breakpoint identification number
		* @callback: Callback to call when the breakpoint has been cleared
		* @user_data: User data that is passed back to the callback
		* @err: Error propagation and reporting.
		*
		* Clear a breakpoint put by any set functions. The Id of the breakpoint
		* is given in the callback of the set functions.
		*
		* Returns: TRUE if the request succeed and the callback is called. If
		* FALSE, the callback will not be called.
		*/
		gboolean clear_breakpoint (guint id, Callback callback, gpointer user_data);

		/**
		* ianjuta_debugger_breakpoint_list_breakpoint:
		* @obj: Self
		* @callback: Callback to call with the list of #IAnjutaDebuggreBreakpointItem
		* @user_data: User data that is passed back to the callback
		* @err: Error propagation and reporting.
		*
		* List all breakpoints set in the debugger. It is useful to
		* know how many time a breakpoint has been hit.
		*
		* Returns: TRUE if the request succeed and the callback is called. If
		* FALSE, the callback will not be called.
		*/
		gboolean list_breakpoint (IAnjutaDebuggerGListCallback callback, gpointer user_data);

		/**
		* ianjuta_debugger_breakpoint_enable_breakpoint:
		* @obj: Self
		* @id: Breakpoint identification number
		* @enable: TRUE to enable the breakpoint, FALSE to disable it
		* @callback: Callback to call when the breakpoint has been changed
		* @user_data: User data that is passed back to the callback
		* @err: Error propagation and reporting.
		*
		* Enable of disable a breakpoint. This function is optional.
		*
		* Returns: TRUE if the request succeed and the callback is called. If
		* FALSE, the callback will not be called.
		*/
		gboolean enable_breakpoint (guint id, gboolean enable, Callback callback, gpointer user_data);

		/**
		* ianjuta_debugger_breakpoint_ignore_breakpoint:
		* @obj: Self
		* @id: Breakpoint identification number
		* @ignore: Number of time a breakpoint must be ignored
		* @callback: Callback to call when the breakpoint has been changed
		* @user_data: User data that is passed back to the callback
		* @err: Error propagation and reporting.
		*
		* This allow to ignore the breakpoint a number of time before stopping.
		* This function is optional.
		*
		* Returns: TRUE if the request succeed and the callback is called. If
		* FALSE, the callback will not be called.
		*/
		gboolean ignore_breakpoint (guint id, guint ignore, Callback callback, gpointer user_data);

		/**
		* ianjuta_debugger_breakpoint_condition_breakpoint:
		* @obj: Self
		* @id: Breakpoint identification number
		* @condition: expression that has to be true
		* @callback: Callback to call when the breakpoint has been changed
		* @user_data: User data that is passed back to the callback
		* @err: Error propagation and reporting.
		*
		* Add a condition, evaluate in the program context, on the breakpoint,
		* the program will stop when it reachs the breakpoint only if the
		* condition is true. This function is optional.
		*
		* Returns: TRUE if the request succeed and the callback is called. If
		* FALSE, the callback will not be called.
		*/
		gboolean condition_breakpoint (guint id, const gchar* condition, Callback callback, gpointer user_data);
	}

	/**
	* SECTION:ianjuta-debugger-variable
	* @title: IAnjutaDebuggerVariable
	* @short_description: Variables interface for debuggers
	* @see_also:
	* @stability: Unstable
	* @include: libanjuta/interfaces/ianjuta-debugger-variable.h
	*
 	* This interface is used to examine and change values of expression.
	* It is based on the MI2 variable object interface of gdb. A
	* variable needs to be created before being able to get or set its
	* value and list its children.
	*/
	interface IAnjutaDebuggerVariable
	{
		/**
		 * IAnjutaDebuggerVariableObject:
		 * @name: unique variable object name created by backend
		 * @expression: corresponding variable name or expression
		 * @type: variable type
		 * @value: variable value
		 * @changed: TRUE if the variable has changed
		 * @exited: TRUE if the variable is outside current scope
		 * @deleted: TRUE if the variable has been removed
		 * @children: Number of variable children, -1 if unknown
		 * @has_more: TRUE if the children value is wrong
		 *
		 * Defines a variable object.
		 */
		struct Object
		{
			gchar *name;
			gchar *expression;
			gchar *type;
			gchar *value;
			gboolean changed;
			gboolean exited;
			gboolean deleted;
			gint children;
			gboolean has_more;
		}

		/**
		 * IAnjutaDebuggerVariableCallback:
		 * @data: a #IAnjutaDebuggerVariableObject object
		 * @user_data: user data passed to the function
		 * @error: error
		 *
		 * This callback function is used to return a #IAnjutaDebuggerVariableObject.
		 */
		typedef void (*Callback) (const Object *data, gpointer user_data, GError* err);

		/**
		* ianjuta_debugger_variable_create:
		* @obj: Self
		* @expression: Variable expression
		* @callback: Callback to call when the variable has been created
		* @user_data: User data that is passed back to the callback
		* @err: Error propagation and reporting.
		*
		* Create a new variable object in the current thread and frame.
		*
		* Returns: TRUE if the request succeed and the callback is
		* called. If FALSE, the callback will not be called.
		*/
		gboolean create (const gchar *expression, Callback callback, gpointer user_data);

		/**
		* ianjuta_debugger_variable_list_children:
		* @obj: Self
		* @name: Variable name
		* @from: Starting from this children (zero-based)
		* @callback: Callback to call when the children have been
		* created with a list of variable objects
		* @user_data: User data that is passed back to the callback
	 	* @err: Error propagation and reporting.
		*
		* List and create objects for variable object's children.
		* The backend can returns only a part of the children, in
		* this case a last variable with a NULL name is added to
		* the list given to the callback function.
		* If the remaining children are wanted, this
		* function must be called again with a from argument
		* corresponding to the first missing children.
		*
		* Returns: TRUE if the request succeed and the callback is
		* called. If FALSE, the callback will not be called.
		*/
		gboolean list_children (const gchar *name, guint from, IAnjutaDebuggerGListCallback callback, gpointer user_data);

		/**
		* ianjuta_debugger_variable_evaluate:
		* @obj: Self
		* @name: Variable name
		* @callback: Callback to call with the variable value
		* @user_data: User data that is passed back to the callback
		* @err: Error propagation and reporting.
		*
		* Get the value of one variable or child object.
		*
		* Returns: TRUE if the request succeed and the callback is
		* called. If FALSE, the callback will not be called.
		*/
		gboolean evaluate (const gchar *name, IAnjutaDebuggerGCharCallback callback, gpointer user_data);

		/**
		* ianjuta_debugger_variable_assign:
		* @obj: Self
		* @name: Variable name
		* @value: Variable value
		* @err: Error propagation and reporting.
		*
		* Set the value of one variable or child object.
		*
		* Returns: TRUE if the request succeed and the callback is
		* called. If FALSE, the callback will not be called.
		*/
		gboolean assign (const gchar *name, const gchar *value);

		/**
		* ianjuta_debugger_variable_update:
		* @obj: Self
		* @callback: Callback to call with the list of all changed
		* variable names
		* @user_data: User data that is passed back to the callback
		* @err: Error propagation and reporting.
		*
		* List all changed variable objects since the last call.
		*
		* Returns: TRUE if the request succeed and the callback is
		* called. If FALSE, the callback will not be called.
		*/
		gboolean update (IAnjutaDebuggerGListCallback callback, gpointer user_data);

		/**
		* ianjuta_debugger_variable_destroy:
		* @obj: Self
		* @name: Variable name
		* @err: Error propagation and reporting.
		*
		* Delete a previously created variable or child object
		* including its own children.
		*
		* Returns: TRUE if the request succeed and the callback is
		* called. If FALSE, the callback will not be called.
		*/
		gboolean destroy (const gchar *name);
	}

	/**
	* SECTION:ianjuta-debugger-register
	* @title: IAnjutaDebuggerRegister
	* @short_description: Register interface for debuggers
	* @see_also:
	* @stability: Unstable
	* @include: libanjuta/interfaces/ianjuta-debugger-register.h
	*
 	* This interface is used to examine and change values of CPU registers.
	*/
	interface IAnjutaDebuggerRegister
	{

		/**
		 * IAnjutaDebuggerRegisterData:
		 * @num: register identifier
		 * @name: register name
		 * @value: register value
		 *
		 * Defines a register data.
		 */
		struct Data
		{
			guint num;
			gchar *name;
			gchar *value;
		}

		/**
		* ianjuta_debugger_register_list_register:
		* @obj: Self
		* @callback: Callback to call with the #IAnjutaDebuggerRegisterData list
		* @user_data: User data that is passed back to the callback
		* @err: Error propagation and reporting.
		*
		* List all registers of the target. This function can be called without
		* a program loaded, the value field of register structure is not filled.
		*
		* Returns: TRUE if the request succeed and the callback is
		* called. If FALSE, the callback will not be called.
		*/
		gboolean list_register (IAnjutaDebuggerGListCallback callback, gpointer user_data);

		/**
		* ianjuta_debugger_register_update_register:
		* @obj: Self
		* @callback: Callback call with the list of all modified #IAnjutaDebuggerRegisterData
		* @user_data: User data that is passed back to the callback
		* @err: Error propagation and reporting.
		*
		* Return all modified registers since the last call. Only the num and
		* value field are used.
		*
		* Returns: TRUE if the request succeed and the callback is
		* called. If FALSE, the callback will not be called.
		*/
		gboolean update_register (IAnjutaDebuggerGListCallback callback, gpointer user_data);

		/**
		* ianjuta_debugger_register_write_register:
		* @obj: Self
		* @value: Modified register with a new value
		* @err: Error propagation and reporting.
		*
		* Change the value of one register. Only the num and value field are used.
		*
		* Returns: TRUE if the request succeed.
		*/
		gboolean write_register (Data *value);
	}

	/**
	* SECTION:ianjuta-debugger-memory
	* @title: IAnjutaDebuggerMemory
	* @short_description: Memory interface for debuggers
	* @see_also:
	* @stability: Unstable
	* @include: libanjuta/interfaces/ianjuta-debugger-memory.h
	*
 	* This interface is used to examine the target memory.
	*/
	interface IAnjutaDebuggerMemory
	{
		/**
		 * IAnjutaDebuggerRegisterMemoryBlock:
		 * @address: start address of memory block
		 * @length: size of memory block
		 * @data: memory block data
		 *
		 * Represent a block of memory.
		 */
		struct Block
		{
			gulong address;
			guint length;
			gchar *data;
		}

		/**
		 * IAnjutaDebuggerMemoryCallback:
		 * @data: a #IAnjutaDebuggerMemoryBlock object
		 * @user_data: user data passed to the function
		 * @error: error
		 *
		 * This callback function is used to return a #IAnjutaDebuggerMemoryBlock.
		 */
		typedef void (*Callback) (const Block *data, gpointer user_data, GError* err);

		/**
		* ianjuta_debugger_memory_inspect:
		* @obj: Self
		* @address: Start address of the memory block
		* @length: Length of memory block
		* @callback: Call back with a IAnjutaDebuggerMemoryBlock as argument
		* @user_data: User data that is passed back to the callback
		* @err: Error propagation and reporting.
		*
		* Read a block of the target memory.
		*
		* Returns: TRUE if the request succeed and the callback is
		* called. If FALSE, the callback will not be called.
		*/
		gboolean inspect (gulong address, guint length, Callback callback, gpointer user_data);
	}

	/**
	* SECTION:ianjuta-debugger-instruction
	* @title: IAnjutaDebuggerInstruction
	* @short_description: Debugger interface for machine instruction
	* @see_also:
	* @stability: Unstable
	* @include: libanjuta/interfaces/ianjuta-debugger-instruction.h
	*
 	* This interface is used to debuger as machine instruction level.
	*/
	interface IAnjutaDebuggerInstruction
	{

		/**
		 * IAnjutaDebuggerInstructionALine:
		 * @address: Address of the line
		 * @label: Optional label
		 * @text: Diassembled instruction on the line
		 *
		 * Defines a disassembled line
		 */
		struct ALine
		{
			gulong address;
			const gchar *label;
			const gchar *text;
		}

		/**
		 * IAnjutaDebuggerInstructionDisassembly:
		 * @size: Number of line
		 * @data: Array of all lines
		 *
		 * Represents a block of diassembled instructions
		 */
		struct Disassembly
		{
			guint size;
			ALine data[];
		}

		/**
		 * IAnjutaDebuggerInstructionCallback:
		 * @data: a #IAnjutaDebuggerInstructionDisassembly object
		 * @user_data: user data passed to the function
		 * @error: error
		 *
		 * This callback function is used to return a #IAnjutaDebuggerInstructionDisassembly.
		 */
		typedef void (*Callback) (const Disassembly *data, gpointer user_data, GError* err);

		/**
		* ianjuta_debugger_instruction_disassemble:
		* @obj: Self
		* @address: Start address of the memory block
		* @length: Length of memory block
		* @callback: Call back with a IAnjutaDebuggerInstructionDisassembly as argument
		* @user_data: User data that is passed back to the callback
		* @err: Error propagation and reporting.
		*
		* Disassemble a part of the memory
		*
		* Returns: TRUE if the request succeed and the callback is
		* called. If FALSE, the callback will not be called.
		*/
		gboolean disassemble (gulong address, guint length, Callback callback, gpointer user_data);

		/**
		* ianjuta_debugger_instruction_step_in_instruction:
		* @obj: Self
		* @err: Error propagation and reporting.
		*
		* Execute one assembler instruction in the program.
		*
		* Returns: TRUE if the request succeed and the callback is called. If
		* FALSE, the callback will not be called.
		*/
		gboolean step_in_instruction ();

		/**
		* ianjuta_debugger_instruction_step_over_instruction:
		* @obj: Self
		* @err: Error propagation and reporting.
		*
		* Execute one assembler instruction in the program, if the instruction
		* is a function call, continues until the function returns.
		*
		* Returns: TRUE if the request succeed and the callback is called. If
		* FALSE, the callback will not be called.
		*/
		gboolean step_over_instruction ();

		/**
		* ianjuta_debugger_instruction_run_to_address:
		* @obj: Self
		* @address: Run to this addresss
		* @err: Error propagation and reporting.
		*
		* Start the program until it reachs the address address
		*
		* Returns: TRUE if the request succeed and the callback is called. If
		* FALSE, the callback will not be called.
		*/
		gboolean run_to_address (gulong address);

		/**
		* ianjuta_debugger_instruction_run_from_address:
		* @obj: Self
		* @address: Run from this addresss
		* @err: Error propagation and reporting.
		*
		* Restart the program starting from address address
		*
		* Returns: TRUE if the request succeed and the callback is called. If
		* FALSE, the callback will not be called.
		*/
		gboolean run_from_address (gulong address);
	}

}

/**
* SECTION:ianjuta-debug-manager
* @title: IAnjutaDebugManager
* @short_description: Common graphical interface to all debugger
* @see_also:
* @stability: Unstable
* @include: libanjuta/interfaces/ianjuta-debug-manager.h
*
* This interface wrap the real debugger plugin and provide a
* common graphical user interface.
*/

interface IAnjutaDebugManager
{
	#include "ianjuta-debugger.h"
	#include "ianjuta-debugger-breakpoint.h"
	#include <gio/gio.h>

	/* Signals */

	/**
	* IAnjutaDebugManager::debugger_started:
	* @obj: Self
	*
	* This signal is emitted when the debugger is started.
	*/
	void ::debugger_started ();

	/**
	* IAnjutaDebugManager::debugger_stopped:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* This signal is emitted when the debugger is stopped.
	*/
	void ::debugger_stopped (GError *err);

	/**
	* IAnjutaDebugManager::program_loaded:
	* @obj: Self
	*
	* This signal is emitted when a program is loaded most of the
	* time just before the first program_stopped signal.
	*/
	void ::program_loaded ();

	/**
	* IAnjutaDebugManager::program_unloaded:
	* @obj: Self
	*
	* This signal is emitted when a program is unloaded. If the
	* debugger is stopped while a program is loaded, this signal
	* is emitted before the debugger_stopped signal.
	*/
	void ::program_unloaded ();

	/**
	* IAnjutaDebugManager::program_started:
	* @obj: Self
	*
	* This signal is emitted when the program is started. If the
	* program starts and is stopped by the debugger, a program-stopped
	* signal will be emitted too. If the program starts is not stopped
	* by the debugger a program-running signal will be emitted.
	*/
	void ::program_started ();

	/**
	* IAnjutaDebugManager::program_exited:
	* @obj: Self
	*
	* This signal is emitted when the program is unloaded. If the
	* debugger is stopped while a program is running or stopped, this
	* signal is emitted before the program_unloaded signal.
	*/
	void ::program_exited ();

	/**
	* IAnjutaDebugManager::program_stopped:
	* @obj: Self
	*
	* This signal is emitted when the program is stopped.
	*/
	void ::program_stopped ();

	/**
	* IAnjutaDebugManager::program_running:
	* @obj: Self
	*
	* This signal is emitted when the program is running.
	*/
	void ::program_running ();


	/**
	* IAnjutaDebugManager::sharedlib_event:
	* @obj: Self
	*
	* This signal is emitted when a new shared library is loaded. It
	* is useful to try to set pending breakpoints those could be in
	* the newly loaded library.
	*/
	void ::sharedlib_event ();

	/**
	* IAnjutaDebugManager::program_moved:
	* @obj: Self
 	* @pid: process id, 0 when unknown
	* @tid: thread id, 0 when unknown
	* @address: program counter address, 0 when unknown
	* @file: source file where is the program counter, NULL when unknown
	* @line: line number if file name above is not NULL
	*
	* This signal is emitted when the debugger know the current program
	* location. Most of the time, after the program has stopped but it
	* could happen even if it is still running.
	*/
	void ::program_moved (gint pid, gint tid, gulong address, const gchar* file, guint line);

	/**
	* IAnjutaDebugManager::frame_changed:
	* @obj: Self
	* @frame: frame
	* @thread: thread
	*
	* This signal is emitted when the current frame is changed. It is
	* equal to the top frame in the interrupted thread when the
	* program stops but can be changed afterward by the user.
	* Several commands use this current frame, by example the register
	* window display the register values for the current thread only.
	*/
	void ::frame_changed (guint frame, gint thread);

	/**
	* IAnjutaDebugManager::location_changed:
	* @obj: Self
	* @address: program counter address, 0 when unknown
	* @uri: source file where is the program counter, NULL when unknown
	* @line: line number if file name above is not NULL
	*
	* This signal is emitted when the current location is changed. It is
	* equal to the program location when the program stops but can be
	* changed afterward by the user.
	*/
	void ::location_changed (gulong address, const gchar* uri, guint line);

	/**
	* IAnjutaDebugManager::signal_received:
	* @obj: Self
	* @name: Signal name
	* @description: Signal description
	*
	* This signal is emitted when the debugged program receives a
	* unix signal.
	*/
	void ::signal_received (const gchar* name, const gchar* description);

	/**
	* IAnjutaDebugManager::breakpoint_changed:
	* @obj: Self
	* @breakpoint: Breakpoint
	* @err: Error propagation and reporting.
	*
	* This signal is emitted when a breakpoint is changed. It includes
	* new breakpoint and deleted breakpoint.
	*/
	void ::breakpoint_changed (IAnjutaDebuggerBreakpointItem *breakpoint);

	/**
	* ianjuta_debug_manager_start:
	* @obj: Self
	* @uri: uri of the target
	* @err: Error propagation and reporting.
	*
	* Start the debugger of the given uri
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean start (const gchar *uri);

   /**
	* ianjuta_debug_manager_start_remote:
	* @obj: Self
	* @server: server (IP address:port)
	* @uri: uri of the local target
	* @err: Error propagation and reporting.
	*
	* Start the debugger of the given uri
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean start_remote (const gchar *server, const gchar *uri);

	/**
	* ianjuta_debug_manager_quit:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Quit the debugger, can wait until the debugger is ready.
	*
	* Returns: TRUE if sucessful, other FALSE.
	*/
	gboolean quit ();
}

/**
 * SECTION:ianjuta-vcs
 * @title: IAnjutaVcs
 * @short_description: Version control system interface
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-vcs.h
 *
 */
interface IAnjutaVcs
{
	#include <gio/gio.h>
	#include <libanjuta/anjuta-vcs-status.h>
	#include <libanjuta/anjuta-async-notify.h>

	/**
	 * IAnjutaVcsError:
	 * @IANJUTA_VCS_UNKNOWN_ERROR: Unkown error
 	 *
 	 * These enumeration is used to specify errors.
	 */
	enum Error
	{
	  UNKOWN_ERROR
	}

	/**
	 * IAnjutaVcsStatus
	 * @obj: Self
 	 *
 	 * This signal is emited when the git pull command is finished, and refreshes the tree of files with the new pulled files without the need to
 	 * fold- unfold the tree.
	 */
	void	::status_changed();

	/**
	 * ianjuta_vcs_add:
	 * @obj: Self
	 * @files: (element-type GFile): List of List of files, represented as #Gfile objects, to add
	 * @notify: #AnjutaAsyncNotify object for finish notification and error
	 * reporting.
	 *
	 * Add files to the VCS repository.
	 */
	void add(List<GFile*> files, AnjutaAsyncNotify *notify);

	/**
	 * ianjuta_vcs_remove:
	 * @obj: Self
	 * @files: (element-type GFile): List of files, represented as #Gfile objects, to remove
	 * @notify: #AnjutaAsyncNotify object for finish notification and error
	 * reporting.
	 *
	 * Remove files from the VCS repository.
	 */
	void remove(List<GFile*> files, AnjutaAsyncNotify *notify);

	/**
	 * ianjuta_vcs_checkout:
	 * @obj: Self
	 * @repository_location: Location of repository to check out
	 * @dest: Destination of checked out copy
	 * @cancel: An optional #GCancellable object to cancel the operation, or NULL
	 * @notify: #AnjutaAsyncNotify object for finish notification and error
	 * reporting.
	 *
	 * Check out a copy of a code repository.
	 */
	void checkout(const gchar *repository_location, GFile *dest, GCancellable *cancel, AnjutaAsyncNotify *notify);

    /**
	 * ianjuta_vcs_query_status:
	 * @obj: Self
	 * @file: File/directory to query
	 * @callback: callback to call when data for a particular file is available
	 * @user_data: User data passed to callback
	 * @cancel: An optional #GCancellable object to cancel the operation, or NULL
	 * @notify: #AnjutaAsyncNotify object for finish notification and error
	 * reporting.
	 *
	 * Querys the status of files in the repository.
	 */
	void query_status (GFile* file, StatusCallback callback, gpointer user_data, GCancellable* cancel, AnjutaAsyncNotify *notify);

    /**
     * IAnjutaVcsStatusCallback:
     * @file: File representing the file for which status is given
     * @status: #AnjutaVcsStatus for the file represented by @file.
     * @user_data: User data
     *
     * Callback called for each status record returned by
     * ianjuta_vcs_query_status.
     */
	typedef void (*StatusCallback) (GFile* file, AnjutaVcsStatus status, gpointer user_data);

    /**
     * ianjuta_vcs_diff:
     * @obj: Self
     * @file: File to diff
     * @callback: Callback to call when diff data becomes available
     * @user_data: User data passed to @callback
     * @cancel: An optional #GCancellable object to cancel the operation, or NULL
     * @notify: #AnjutaAsyncNotify object for finish notification and error
	 * reporting.
     *
     * Generates a unified diff of the file represented by @file.
     */
	void diff(GFile* file, DiffCallback callback, gpointer user_data, GCancellable* cancel, AnjutaAsyncNotify *notify);

    /**
     * IAnjutaVcsDiffCallback:
     * @file: File being diffed
     * @diff: Diff data
     * @user_data: User data
     *
     * Called when diff data comes from ianjuta_vcs_diff.
     */
	typedef void (*DiffCallback) (GFile* file, const gchar* diff, gpointer user_data);
}

/**
 * SECTION:ianjuta-snippets-manager
 * @title: IAnjutaSnippetsManager
 * @short_description: Snippets Manager interface
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-macro.h
 *
 */
interface IAnjutaSnippetsManager
{
	/**
	 * ianjuta_snippets_manager_insert:
	 * @key: Trigger-key of the snippet
	 * @editing_session: If after inserting the snippet there should be an editing
	 * session. Mark as FALSE if not interested in the dynamic capabilities of the
	 * snippet.
	 * @obj: Self
	 * @err: Error propagation and reporting
	 *
	 * Insert snippet in the current editor.
	 */
	gboolean insert (const gchar* key, gboolean editing_session);
}

/**
 * SECTION:ianjuta-symbol
 * @title: IAnjutaSymbol
 * @short_description: Source code symbol interface
 * @see_also: #IAnjutaSymbolQuery, #IAnjutaSymbolManager
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-symbol.h
 *
 * This interface is used to define a symbol, normally got from symbol
 * queries. A symbol has various fields that can be retrieved by using
 * their get methods. A symbol will have only those fields which have
 * been selected to be included in their respective queries, so make sure
 * the needed fields are correctly specified during query creation.
 */
interface IAnjutaSymbol
{
	#include <gdk/gdk.h>
	#include <gio/gio.h>

	/**
	 * IAnjutaSymbolType:
	 * @IANJUTA_SYMBOL_TYPE_NONE: None spedified.
	 * @IANJUTA_SYMBOL_TYPE_UNDEF: Unknown type.
	 * @IANJUTA_SYMBOL_TYPE_CLASS: Class declaration
	 * @IANJUTA_SYMBOL_TYPE_ENUM: Enum declaration
	 * @IANJUTA_SYMBOL_TYPE_ENUMERATOR: Enumerator value
	 * @IANJUTA_SYMBOL_TYPE_FIELD: Field (Java only)
	 * @IANJUTA_SYMBOL_TYPE_FUNCTION: Function definition
	 * @IANJUTA_SYMBOL_TYPE_INTERFACE: Interface (Java only)
	 * @IANJUTA_SYMBOL_TYPE_MEMBER: Member variable of class/struct
	 * @IANJUTA_SYMBOL_TYPE_METHOD: Class method (Java only)
	 * @IANJUTA_SYMBOL_TYPE_NAMESPACE: Namespace declaration
	 * @IANJUTA_SYMBOL_TYPE_PACKAGE: Package (Java only)
	 * @IANJUTA_SYMBOL_TYPE_PROTOTYPE: Function prototype
	 * @IANJUTA_SYMBOL_TYPE_STRUCT: Struct declaration
	 * @IANJUTA_SYMBOL_TYPE_TYPEDEF: Typedef
	 * @IANJUTA_SYMBOL_TYPE_UNION: Union
	 * @IANJUTA_SYMBOL_TYPE_VARIABLE: Variable
	 * @IANJUTA_SYMBOL_TYPE_EXTERNVAR: Extern or forward declaration
	 * @IANJUTA_SYMBOL_TYPE_MACRO: Macro (without arguments)
	 * @IANJUTA_SYMBOL_TYPE_MACRO_WITH_ARG: Parameterized macro
	 * @IANJUTA_SYMBOL_TYPE_FILE: File (Pseudo tag)
	 * @IANJUTA_SYMBOL_TYPE_OTHER: Other (non C/C++/Java tag)
	 * @IANJUTA_SYMBOL_TYPE_SCOPE_CONTAINER: types which are subjected to create a scope.
	 * @IANJUTA_SYMBOL_TYPE_MAX: Maximum value, used as end marker.
	 */
	enum Type
	{
		TYPE_NONE = 0,
		TYPE_UNDEF = 1,
		TYPE_CLASS = 2,
		TYPE_ENUM = 4,
		TYPE_ENUMERATOR = 8,
		TYPE_FIELD = 16,
		TYPE_FUNCTION = 32,
		TYPE_INTERFACE = 64,
		TYPE_MEMBER = 128,
		TYPE_METHOD = 256,
		TYPE_NAMESPACE = 512,
		TYPE_PACKAGE = 1024,
		TYPE_PROTOTYPE = 2048,
		TYPE_STRUCT = 4096,
		TYPE_TYPEDEF = 8192,
		TYPE_UNION = 16384,
		TYPE_VARIABLE = 32768,
		TYPE_EXTERNVAR = 65536,
		TYPE_MACRO = 131072,
		TYPE_MACRO_WITH_ARG = 262144,
		TYPE_FILE = 524288,
		TYPE_OTHER = 1048576,
		TYPE_SCOPE_CONTAINER = IANJUTA_SYMBOL_TYPE_CLASS | IANJUTA_SYMBOL_TYPE_ENUM | IANJUTA_SYMBOL_TYPE_INTERFACE | IANJUTA_SYMBOL_TYPE_NAMESPACE | IANJUTA_SYMBOL_TYPE_PACKAGE | IANJUTA_SYMBOL_TYPE_STRUCT | IANJUTA_SYMBOL_TYPE_UNION,
		TYPE_MAX = 2097151
	}

	/**
	 * IAnjutaSymbolField:
	 * @IANJUTA_SYMBOL_FIELD_ID: Integer. A unique ID of the symbol
	 * @IANJUTA_SYMBOL_FIELD_NAME: String. Name of the symbol
	 * @IANJUTA_SYMBOL_FIELD_FILE_POS: Integer. The file line number where the symbol is found.
	 * @IANJUTA_SYMBOL_FIELD_SCOPE_DEF_ID: Integer. A unique ID to define scope created by this symbol.
	 * @IANJUTA_SYMBOL_FIELD_FILE_SCOPE: Boolean: TRUE if symbol is within file scope,
	 *     otherwise FALSE.
	 * @IANJUTA_SYMBOL_FIELD_SIGNATURE: String. Signature of a method, if symbol is a funtion.
	 *     Namely, the arguments list of the funtion.
	 * @IANJUTA_SYMBOL_FIELD_RETURNTYPE: String. Return type of a method, if symbol is a function.
	 * @IANJUTA_SYMBOL_FIELD_FILE_PATH: String. The relative path to the file where the symbol is found.
	 * @IANJUTA_SYMBOL_FIELD_PROJECT_NAME: String. The project name to which the symbol belongs to.
	 * @IANJUTA_SYMBOL_FIELD_PROJECT_VERSION: String. The project version to which the symbol belongs to.
	 * @IANJUTA_SYMBOL_FIELD_IMPLEMENTATION: String. Implementation attribute of a symbol. It may be
	 *     "pure virtual", "virtual", etc.
	 * @IANJUTA_SYMBOL_FIELD_ACCESS: String. Access attribute of a symbol.
	 *     It may be "public", "private" etc.
	 * @IANJUTA_SYMBOL_FIELD_KIND: Kind attribute of a symbol, such as
	 *     "enumerator", "namespace", "class" etc.
	 * @IANJUTA_SYMBOL_FIELD_TYPE: Both string and Integer. Type attribute of a symbol.
	 *     In string form, it is name of the type in string form.
	 *     In integer form, it is IAnjutaSymbolType enumerator value.
	 * @IANJUTA_SYMBOL_FIELD_TYPE_NAME: type_name attribute of a symbol.
	 *     If a type could be "class" then its type_name may be "MyFooClass" etc.
	 * @IANJUTA_SYMBOL_FIELD_IS_CONTAINER: Boolean. TRUE if symbol is
	 *     a scope container, such as namespace, class, struct etc., otherwise
	 *     FALSE.
	 * @IANJUTA_SYMBOL_FIELD_END: The end marker.
	 *
	 * Symbol Fields. Used to define and retrieve results from query. Each of
	 * these fields are either integer or string. Use the right method to
	 * retrieve them. That is, for integer use ianjuta_symbol_get_int(),
	 * for string use ianjuta_symbol_get_string(), and for boolean use
	 * ianjuta_symbol_get_boolean(). Some fields can be in both forms,
	 * e.g. #IANJUTA_SYMBOL_FIELD_TYPE.
	 */
	enum Field
	{
		FIELD_ID,
		FIELD_NAME,
		FIELD_FILE_POS,
		FILED_SCOPE_DEF_ID,
		FIELD_FILE_SCOPE,
		FIELD_SIGNATURE,
		FIELD_RETURNTYPE,
		FIELD_TYPE,
		FIELD_TYPE_NAME,
		FIELD_FILE_PATH,
		FIELD_PROJECT_NAME,
		FIELD_PROJECT_VERSION,
		FIELD_IMPLEMENTATION,
		FIELD_ACCESS,
		FIELD_KIND,
		FIELD_IS_CONTAINER,
		FIELD_END
	}

	/**
	 * ianjuta_symbol_get_boolean:
	 * @obj: Self
	 * @field: The field to retrieve.
	 * @err: Error propagation and reporting.
	 *
	 * Retreives the boolean value of a boolean @field.
	 *
	 * Returns: The boolean
	 */
	gboolean get_boolean (Field field);

	/**
	 * ianjuta_symbol_get_int:
	 * @obj: Self
	 * @field: The field to retrieve.
	 * @err: Error propagation and reporting.
	 *
	 * Retreives the integer value of an integer @field.
	 *
	 * Returns: The integer
	 */
	gint get_int (Field field);

	/**
	 * ianjuta_symbol_get_string:
	 * @obj: Self
	 * @field: The field to retrieve.
	 * @err: Error propagation and reporting.
	 *
	 * Retreives the string value of a string @field.
	 *
	 * Returns: The string
	 */
	const gchar* get_string (Field field);

	/**
	 * ianjuta_symbol_get_file:
	 * @obj: Self
	 * @err: Error propagation and reporting.
	 *
	 * A convenience method to get GFile object for
	 * #IANJUTA_SYMBOL_FIELD_FILE_PATH field. The file where the
	 * symbol is declared. It contains the absolute path of the file
	 * unlike raw value of field #IANJUTA_SYMBOL_FIELD_FILE_PATH.
	 *
	 * Returns: A GFile object. It must be unrefed after use.
	 */
	GFile* get_file();

	/**
	 * ianjuta_symbol_get_sym_type:
	 * @obj: Self
	 * @err: Error propagation and reporting.
	 *
	 * A convenience method to get value of #IANJUTA_SYMBOL_FIELD_TYPE
	 * field typecasted to IAnjutaSymbolType. Numerical value is unchanged.
	 *
	 * Returns: a #IAnjutaSymbolType
	 */
	Type get_sym_type ();

	/**
	 * ianjuta_symbol_get_icon:
	 * @obj: Self
	 * @err: Error propagation and reporting.
	 *
	 * A convenience method to get a small icon (16x16) representing the symbol
	 * kind. You *need* a query with fields #IANJUTA_SYMBOL_FIELD_ACCESS and
	 * #IANJUTA_SYMBOL_FIELD_KIND selected.
	 *
	 * Returns: a Pixbuf icon representing the symbol. Ref the icon if you
	 * need to keep it.
	 */
	const GdkPixbuf *get_icon ();
}

/**
 * SECTION:ianjuta-symbol-query
 * @title: IAnjutaSymbolQuery
 * @short_description: Source code symbol query interface
 * @see_also: #IAnjutaSymbolManager, #IAnjutaSymbol
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-symbol-query.h
 *
 * A query object will have this interface that allows to tweak various
 * query parameters. Except for the #IAnjutaSymbolQueryName and
 * #IAnjutaSymbolQueryDb parameters, everything else is changable
 * post-creation.
 *
 * Note that chaning a query parameter, except for limit and offset will
 * result in re-preparing the query the next time it is executed, so it is
 * not advisable to change it each time the query is executed. For such
 * cases, create different queries with different parameters.
 *
 * A query is signified by a name enumeration (#IAnjutaSymbolQueryName) which
 * practically determines the query type and its execution condition. Each
 * query name is assigned to pre-defined query statement and can only be
 * set during creation time. Then only its specific ianjuta_symbol_query_search_*()
 * can be used to execute the query. These specific execution methods are
 * provided to make it convenient to pass query parameters easily and to
 * ensure all the needed parameters are given.
 *
 * A query can run in different modes, defined by #IAnjutaSymbolQueryMode, by
 * default it is executed in synchrounous mode #IANJUTA_SYMBOL_QUERY_MODE_SYNC
 * and can be changed using ianjuta_symbol_query_set_mode().
 * #IANJUTA_SYMBOL_QUERY_MODE_ASYNC runs it in asynchronous mode in a separate
 * thread and can be canceled with ianjuta_symbol_query_cancel().
 *
 * A query runs on a database, defined by #IAnjutaSymbolQueryDb, and can be
 * only selected at creatation time.
 *
 * In addition, there are many other filters that can be set to the query
 * to refine the query results. For example, ianjuta_symbol_query_set_fields()
 * is used to set the needed symbol fields to retrieve, ianjuta_symbol_query_set_filters()
 * is used to filter the results with symbol types, ianjuta_symbol_query_set_file_scope()
 * limits the results to either public or private scope within the source file,
 * ianjuta_symbol_query_set_group_by() is used to group the results on a given
 * field, ianjuta_symbol_query_set_order_by is used to order the results on a
 * given field.
 *
 * ianjuta_symbol_query_set_limit() and ianjuta_symbol_query_set_offset() are
 * used to change limit and offset of the resultset. Note again that these
 * parameters do not require re-preparation of query, so can be safely used
 * any time without performance hit.
 */
interface IAnjutaSymbolQuery
{
	#include "ianjuta-iterable.h"
	#include "ianjuta-symbol.h"

	/**
	 * IAnjutaSymbolQueryMode:
	 * @IANJUTA_SYMBOL_QUERY_MODE_SYNC: Syncronous query. The result is immediately
	 *     available as retrun value of search call.
	 * @IANJUTA_SYMBOL_QUERY_MODE_ASYNC: Asynchronous query. The search call
	 *     return immediately and result delievered as a signal later. The actual
	 *     query is done in a separate thread.
	 * @IANJUTA_SYMBOL_QUERY_MODE_QUEUED: If the database is busy
	 *     scanning, then the query is performed later when database is ready.
	 *     It returns NULL and result is delivered through async-result signal.
	 *     Only query can stay queued, so calling search multiple times would
	 *     result in only the last one being active.
	 *
	 * This parameter determines the mode of query execution. By default,
	 * IANJUTA_SYMBOL_QUERY_MODE_SYNC is selected.
	 */
	enum Mode
	{
		MODE_SYNC,
		MODE_ASYNC,
		MODE_QUEUED
	}

	/**
	 * IAnjutaSymbolQueryDb:
	 * @IANJUTA_SYMBOL_QUERY_DB_PROJECT: Select project database.
	 * @IANJUTA_SYMBOL_QUERY_DB_SYSTEM: Select system database.
	 *
	 * Sets the database to use for the query. System database is where
	 * all system library symbols are found. While project database is where
	 * currently open project's symbols are found.
	 */
	enum Db
	{
		DB_PROJECT,
		DB_SYSTEM
	}

	/**
	 * IAnjutaSymbolQueryName:
	 * @IANJUTA_SYMBOL_QUERY_SEARCH: Query to perform basic substring search.
	 * @IANJUTA_SYMBOL_QUERY_SEARCH_ALL: Query to get all symbols
	 * @IANJUTA_SYMBOL_QUERY_SEARCH_FILE: Query to perform substring search in a file.
	 * @IANJUTA_SYMBOL_QUERY_SEARCH_IN_SCOPE: Query to perform substring search in a scope.
	 * @IANJUTA_SYMBOL_QUERY_SEARCH_ID: Query to find the symbol of given ID.
	 * @IANJUTA_SYMBOL_QUERY_SEARCH_MEMBERS: Query to find members of a scope (eg. class).
	 * @IANJUTA_SYMBOL_QUERY_SEARCH_CLASS_PARENTS: Query to get parents of a class.
	 * @IANJUTA_SYMBOL_QUERY_SEARCH_SCOPE: Query to find scope name of a file position.
	 * @IANJUTA_SYMBOL_QUERY_SEARCH_PARENT_SCOPE: Query to get the parent scope of a symbol.
	 * @IANJUTA_SYMBOL_QUERY_SEARCH_PARENT_SCOPE_FILE: Query to get the parent scope of a symbol in the file.
	 *
	 * Names of query that defined what kind of query it is.
	 */
	enum Name
	{
		SEARCH,
		SEARCH_ALL,
		SEARCH_FILE,
		SEARCH_IN_SCOPE,
		SEARCH_ID,
		SEARCH_MEMBERS,
		SEARCH_CLASS_PARENTS,
		SEARCH_SCOPE,
		SEARCH_PARENT_SCOPE,
		SEARCH_PARENT_SCOPE_FILE
	}

	/**
	 * IAnjutaSymbolQueryFileScope:
	 * @IANJUTA_SYMBOL_QUERY_SEARCH_FS_IGNORE: Ignore file scope
	 * @IANJUTA_SYMBOL_QUERY_SEARCH_FS_PUBLIC: Only public symbols visible to rest of project.
	 * @IANJUTA_SYMBOL_QUERY_SEARCH_FS_PRIVATE: Only private symbols visible inside a file.
	 *
	 * Defines file scope of symbols to query.
	 */
	enum FileScope
	{
		SEARCH_FS_IGNORE,
		SEARCH_FS_PUBLIC,
		SEARCH_FS_PRIVATE
	}

	/**
	 * IAnjutaSymbolQuery::async_result:
	 * @ianjutasymbolquery: Self
	 * @arg1: Query result (IAnjutaIterable, IAnjutaSymbol) of an async
	 *     or queued search. NULL if no result is found or some error happened.
	 *
	 * This signal is emitted for every search of the Query involved in async
	 * mode, unless cancled by ianjuta_symbol_query_cancel(). For single queued
	 * query, only result of the last search is emitted (if it wasn't database
	 * was busy when search was invoked). Unlike in sync counterpart,
	 * do not unref @result after use.
	 */
	void ::async_result (GObject* result);

	/**
	 * ianjuta_symbol_query_set_mode:
	 * @obj: Self
	 * @mode: The mode of query.
	 * @err: Error propagation and reporting.
	 *
	 * Sets the mode of Query.
	 */
	void set_mode (IAnjutaSymbolQueryMode mode);

	/**
	 * ianjuta_symbol_query_set_fields:
	 * @obj: Self
	 * @n_fields: Then number of fields to retrieve.
	 * @fields: The fields to retrieve in the query. The array length must
	 *   be @n_fields.
	 * @err: Error propagation and reporting.
	 *
	 * Sets the fields of Query.
	 */
	void set_fields (gint n_fields, IAnjutaSymbolField *fields);

	/**
	 * ianjuta_symbol_query_set_filters:
	 * @obj: Self
	 * @filters: The mode of query.
	 * @include_types: TRUE if filter is positive, FALSE if reversed.
	 * @err: Error propagation and reporting.
	 *
	 * Sets the bit mask of symbol type filters. if @include_types is TRUE,
	 * symbols satisfying the given symbol types are selected, otherwise
	 * they are excluded.
	 */
	void set_filters (IAnjutaSymbolType filters, gboolean includes_types);

	/**
	 * ianjuta_symbol_query_set_file_scope:
	 * @obj: Self
	 * @filescope_search: The filescope to search.
	 * @err: Error propagation and reporting.
	 *
	 * Sets the filescope search of Query.
	 */
	void set_file_scope (IAnjutaSymbolQueryFileScope filescope_search);

	/**
	 * ianjuta_symbol_query_set_offset:
	 * @obj: Self
	 * @offset: Offset of the resultset.
	 * @err: Error propagation and reporting.
	 *
	 * Sets the offset index of Query results.
	 */
	void set_offset (gint offset);

	/**
	 * ianjuta_symbol_query_set_limit:
	 * @obj: Self
	 * @limit: The limit of query.
	 * @err: Error propagation and reporting.
	 *
	 * Sets the limit of Query results. No more than @limit results are
	 * returned.
	 */
	void set_limit (gint limit);

	/**
	 * ianjuta_symbol_query_set_group_by:
	 * @obj: Self
	 * @field: The field to group results.
	 * @err: Error propagation and reporting.
	 *
	 * Sets the field with which result of query is grouped. As a result
	 * there will be no duplicates of with this field.
	 */
	void set_group_by (IAnjutaSymbolField field);

	/**
	 * ianjuta_symbol_query_set_order_by:
	 * @obj: Self
	 * @field: The field to order the result.
	 * @err: Error propagation and reporting.
	 *
	 * Sets the field with which result of query is ordered.
	 */
	void set_order_by (IAnjutaSymbolField field);

	/**
	 * ianjuta_symbol_query_set_cancel:
	 * @obj: Self
	 * @err: Error propagation and reporting.
	 *
	 * Cancels any pending non-sync searches. After calling this, it is
	 * guaranteed that "async-result" will not be called any more for any
	 * past searches. New searches will have their results signaled as
	 * normal.
	 */
	void cancel ();

	/**
	 * ianjuta_symbol_query_search:
	 * @obj: Self
	 * @pattern: Search pattern in compliance with SQL LIKE syntax
	 * @err: Error propagation and reporting.
	 *
	 * Executes #IANJUTA_SYMBOL_QUERY_SEARCH query.
	 */
	IAnjutaIterable* search (const gchar *pattern);

	/**
	 * ianjuta_symbol_query_search_all:
	 * @obj: Self
	 * @err: Error propagation and reporting.
	 *
	 * Executes #IANJUTA_SYMBOL_QUERY_SEARCH_ALL query.
	 */
	IAnjutaIterable* search_all ();

	/**
	 * ianjuta_symbol_query_search_file:
	 * @obj: Self
	 * @pattern: Search pattern in compliance with SQL LIKE syntax
	 * @file: The file whose symbols are searched.
	 * @err: Error propagation and reporting.
	 *
	 * Executes #IANJUTA_SYMBOL_QUERY_SEARCH_FILE query.
	 */
	IAnjutaIterable* search_file (const gchar *pattern, const GFile *file);

	/**
	 * ianjuta_symbol_query_search_in_scope:
	 * @obj: Self
	 * @pattern: Search pattern in compliance with SQL LIKE syntax
	 * @scope: The scope inside which symbols are searched.
	 * @err: Error propagation and reporting.
	 *
	 * Executes #IANJUTA_SYMBOL_QUERY_SEARCH_IN_SCOPE query.
	 */
	IAnjutaIterable* search_in_scope (const gchar *pattern, IAnjutaSymbol *scope);

	/**
	 * ianjuta_symbol_query_search_members:
	 * @obj: Self
	 * @symbol: The symbol whose members to get.
	 * @err: Error propagation and reporting.
	 *
	 * Executes #IANJUTA_SYMBOL_QUERY_SEARCH_MEMBERS query.
	 */
	IAnjutaIterable* search_members (IAnjutaSymbol *symbol);

	/**
	 * ianjuta_symbol_query_search_class_parents:
	 * @obj: Self
	 * @symbol: The class symbol whose parents to get.
	 * @err: Error propagation and reporting.
	 *
	 * Executes #IANJUTA_SYMBOL_QUERY_SEARCH_CLASS_PARENTS query.
	 */
	IAnjutaIterable* search_class_parents (IAnjutaSymbol *symbol);

	/**
	 * ianjuta_symbol_query_search_id:
	 * @obj: Self
	 * @symbol: The symbol id whose details to get.
	 * @err: Error propagation and reporting.
	 *
	 * Executes #IANJUTA_SYMBOL_QUERY_SEARCH_ID query.
	 */
	IAnjutaIterable* search_id (gint symbol_id);

	/**
	 * ianjuta_symbol_query_search_scope:
	 * @obj: Self
	 * @file_path: The file where the scope is.
	 * @line: The line where the scope is.
	 * @err: Error propagation and reporting.
	 *
	 * Executes #IANJUTA_SYMBOL_QUERY_SEARCH_SCOPE query.
	 */
	IAnjutaIterable* search_scope (const gchar *file_path, gint line);

	/**
	 * ianjuta_symbol_query_search_parent_scope:
	 * @obj: Self
	 * @symbol: The symbol whose parent scope is to be found.
	 * @err: Error propagation and reporting.
	 *
	 * Executes #IANJUTA_SYMBOL_QUERY_SEARCH_PARENT_SCOPE query.
	 */
	IAnjutaIterable* search_parent_scope (IAnjutaSymbol *symbol);

	/**
	 * ianjuta_symbol_query_search_parent_scope_file:
	 * @symbol: The symbol whose parent scope is to be found.
	 * @obj: Self
	 * @file_path: The file where the parent scope is to be found.
	 * @err: Error propagation and reporting.
	 *
	 * Executes #IANJUTA_SYMBOL_QUERY_SEARCH_PARENT_SCOPE_FILE query.
	 */
	IAnjutaIterable* search_parent_scope_file (IAnjutaSymbol *symbol, const gchar *file_path);
}

/**
 * SECTION:ianjuta-symbol-manager
 * @title: IAnjutaSymbolManager
 * @short_description: Source code symbols manager inteface
 * @see_also: #IAnjutaSymbol
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-symbol-manager.h
 *
 */
interface IAnjutaSymbolManager
{
	#include <libanjuta/anjuta-async-notify.h>
	#include "ianjuta-iterable.h"
	#include "ianjuta-symbol.h"
	#include "ianjuta-symbol-query.h"

	/**
	 * IAnjutaSymbolManager::prj_scan_end:
	 * @obj: Self
	 *
	 * This signal is emitted when a scanning of one or more files on project db
	 * ends.
	 */
	void ::prj_scan_end (gint process_id);

	/**
	 * IAnjutaSymbolManager::sys_scan_end:
	 * @obj: Self
	 *
	 * This signal is emitted when a scanning of one or more packages on system db
	 * ends. This signal doesn't mean that all the scan process for the packages
	 * is ended, but that just one (or more) is (are).
	 */
	void ::sys_scan_end (gint process_id);

	/**
	 * ianjuta_symbol_manager_create_query:
	 * @obj: Self
	 * @name: Name of the query. It decides what query type it is.
	 * @db: The database to use.
	 * @err: Error propagation and reporting.
	 *
	 * Create a query object. By default only #IANJUTA_SYMBOL_FIELD_ID and
	 * and #IANJUTA_SYMBOL_FIELD_NAME are selected, limit is set to infinity,
	 * offset is set to 0, no filters are set and mode is set to
	 * #IANJUTA_SYMBOL_QUERY_MODE_SYNC.
	 *
	 * Returns: A #IAnjutaSymbolQuery object
	 */
	IAnjutaSymbolQuery* create_query (IAnjutaSymbolQueryName name, IAnjutaSymbolQueryDb db);

	/**
	 * ianjuta_symbol_manager_add_package:
	 * @obj: Self
 	 * @pkg_name: Name of the package to scan. Should be the name given by
	 * pkg-config. The colon char must be avoided.
 	 * @pkg_version: Version of the package. The colon char must be avoided.
 	 * or by the language implementation (Python, Javascript, etc.)
 	 * @files: A list of GFile's to scan for this package
 	 *
 	 * Reads the package files into the database asynchronously.
	 *
	 * Returns: TRUE if the package will be loaded into the db, FALSE if the package
	 * already exists
 	 */
	gboolean add_package (const gchar* pkg_name, const gchar* pkg_version, GList* files);

	/**
	 * ianjuta_symbol_manager_activate_package:
	 * @obj: Self
 	 * @pkg_name: Name of the package to activate. The colon char must be avoided.
 	 * @pkg_version: Version of the package. The colon char must be avoided.
 	 *
 	 * Activates the package for searches in the global symbol database.
 	 *
 	 * Returns: TRUE if the package was loaded (or will be loaded once scanned).
 	 * FALSE if the version given was newer than the version in the database or the
 	 * package was not found. In this case, add_package() should be called.
 	 */
	gboolean activate_package (const gchar *pkg_name, const gchar* pkg_version);

	/**
	 * ianjuta_symbol_manager_deactivate_package:
	 * @obj: Self
 	 * @pkg_name: name of the package. The colon char must be avoided.
	 * @pkg_version: Version of the package. The colon char must be avoided.
 	 *
 	 * Deactivates the package if it was found. If package is NULL, deactivate all
 	 * packages.
	 *
 	 */
	void deactivate_package (const gchar* pkg_name, const gchar* pkg_version);

	/**
	 * ianjuta_symbol_manager_deactivate_all:
	 * @obj: Self
 	 *
 	 * Deactivates all activate packages
	 *
 	 */
	void deactivate_all ();
}

/**
 * SECTION:ianjuta-print
 * @title: IAnjutaPrint
 * @short_description: Print interface
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-print.h
 *
 */
interface IAnjutaPrint
{
	/**
	* ianjuta_print_print:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Print the plugin (the file in case of the editor). In most cases this will show
	* a print dialog
	*/
	void print();

	/**
	* ianjuta_print_print:
	* @obj: Self
	* @err: Error propagation and reporting.
	*
	* Show print preview dialog
	*/

	void print_preview();
}

/**
 * SECTION:ianjuta-preferences
 * @title: IAnjutaPreferences
 * @short_description: Preferences interface
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-preferences
 *
 */
interface IAnjutaPreferences
{
	#include <libanjuta/anjuta-preferences.h>
	/**
	 * ianjuta_preferences_merge:
	 * @obj: Self
	 * @prefs: AnjutaPreferences to install to
	 * @err: Error propagation and reporting.
	 *
	 * When called, the plugin should install it's preferences
	 */
	void merge(AnjutaPreferences* prefs);

	/**
	 * ianjuta_preferences_unmerge:
	 * @obj: Self
	 * @prefs: AnjutaPreferences to install to
	 * @err: Error propagation and reporting.
	 *
	 * When called, the plugin should uninstall it's preferences
	 */
	void unmerge(AnjutaPreferences* prefs);
}

/**
 * SECTION:ianjuta-plugin-factory
 * @title: IAnjutaPluginFactory
 * @short_description: Create Anjuta plugin objects
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-plugin-factory.h
 *
 * This interface is used to create all Anjuta plugin objects. It is
 * already implemented inside Anjuta by an object able to load plugins written
 * in C. In order to load plugins in other languages (or in a different way),
 * a loader plugin implementing this interface must be written first, probably
 * in C.
 */

interface IAnjutaPluginFactory
{
	#include <libanjuta/anjuta-plugin.h>
	#include <libanjuta/anjuta-shell.h>
	#include <libanjuta/anjuta-plugin-handle.h>

	/**
	 * IAnjutaPluginFactoryError:
	 * @IANJUTA_PLUGIN_FACTORY_MISSING_LOCATION: Module file location is
	 *	missing in .plugin file
	 * @IANJUTA_PLUGIN_FACTORY_MISSING_TYPE: Plugin type (just after
	 *	double colon following location) is missing in .plugin file
	 * @IANJUTA_PLUGIN_FACTORY_MISSING_MODULE: Module file name not found,
	 *	plugin module is probably not installed
	 * @IANJUTA_PLUGIN_FACTORY_INVALID_MODULE: Module file cannot be
	 *	loaded, not a shared library perhaps
	 * @IANJUTA_PLUGIN_FACTORY_MISSING_FUNCTION: Module does not contain
	 *	registration function, library is not an anjuta plugin or
	 *	is not for the right version
	 * @IANJUTA_PLUGIN_FACTORY_INVALID_TYPE: Module has not registered
	 * 	plugin type, library is not an anjuta plugin or not for
	 *	the right version
	 * @IANJUTA_PLUGIN_FACTORY_UNKNOWN_ERROR: Another error
 	 *
 	 * These enumeration is used to specify errors.
	 */
	enum Error
	{
		OK = 0,
		MISSING_LOCATION,
		MISSING_TYPE,
		MISSING_MODULE,
		INVALID_MODULE,
		MISSING_FUNCTION,
		INVALID_TYPE,
		UNKNOWN_ERROR,
	}

	/**
	 * ianjuta_plugin_factory_new_plugin:
	 * @obj: Self
	 * @handle: Plugin information
	 * @shell: Anjuta shell
	 * @err: Error propagation and reporting.
	 *
	 * Create a new AnjutaPlugin object from the plugin information handle,
	 * give it the AnjutaShell object as argument.
	 *
	 * Return value: a new plugin object
	 */
	AnjutaPlugin* new_plugin (AnjutaPluginHandle* handle, AnjutaShell *shell);
}

/**
 * SECTION:ianjuta-language
 * @title: IAnjutaLanguage
 * @short_description: Interface to manage multiple programming languages
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-language.h
 *
 */

interface IAnjutaLanguage
{
  #include <libanjuta/interfaces/ianjuta-editor-language.h>
typedef gint Id;

	/**
	 * ianjuta_language_from_mime_type:
	 * @obj: Self
	 * @mime_type: A mime type to get the language for
	 *
	 * Returns: A language Id or 0 in case no language was found
	 */
	 Id get_from_mime_type (const gchar* mime_type);

	/**
	 * ianjuta_language_from_string:
	 * @obj: Self
	 * @string: A string representation of the language. Note that multiple
	 * strings may describe the language like C++ and Cpp
	 *
	 * Returns: A language Id or 0 in case no language was found
	 */
	 Id get_from_string (const gchar* string);

 	/**
	 * ianjuta_language_get_name:
	 * @obj: Self
	 * @id: A valid language id
	 *
	 * Returns: The main name of the language. When you call ianjuta_language_from_string()
	 * before that method the string you get here might be different to the one you passed
	 * because the language might have multiple string representations
	 */
	 const gchar* get_name(Id id);

	/**
	 * ianjuta_language_get_make_target:
	 * @obj: Self
	 * @id: A valid language id
	 *
	 * Returns: The suffix for the file thats needs to be passed to
	 * make to compile the file, e.g. ".o" for C
	 */
	 const gchar* get_make_target (Id id);

	/**
	 * ianjuta_language_get_strings:
	 * @obj: Self
	 * @id: A valid language id
	 *
	 * Returns: (element-type utf8): A list of strings that represent this language
	 */
	 List<const gchar*> get_strings(Id id);

    /**
	 * ianjuta_language_get_mime_types:
	 * @obj: Self
	 * @id: A valid language id
	 *
	 * Returns: (element-type utf8): A list of mime-types that represent this language
	 */
	 List<const gchar*> get_mime_types(Id id);

	/**
	 * ianjuta_language_get_from_editor:
	 * @obj: Self
	 * @editor: An object implementing IAnjutaEditorLanguage
	 * @err: Error propagation
	 *
	 * Conviniece method to get the id directly from the editor
	 *
	 * Returns: A valid language id or 0
	 */
	 IAnjutaLanguageId get_from_editor (IAnjutaEditorLanguage* editor);

	/**
	 * ianjuta_language_get_name_from_editor:
	 * @obj: Self
	 * @editor: An object implementing IAnjutaEditorLanguage
	 * @err: Error propagation
	 *
	 * Conviniece method to get the name directly from the editor
	 *
	 * Returns: A language name or NULL
	 */
	 const gchar* get_name_from_editor (IAnjutaEditorLanguage* editor);

	/**
	 * ianjuta_language_get_languages:
	 * @obj: Self
	 * @err: Error propagation
	 *
	 * Returns: (element-type int) (transfer container): a list of ids of the available
	 * languages. Use GPOINTER_TO_INT() to receive them. The list but not the
	 * values should be free'd with g_list_free()
	 */
	 GList* get_languages ();
}

/**
 * SECTION:ianjuta-indenter
 * @title: IAnjutaIndenter
 * @short_description: Interface for automatic indentation
 * @see_also:
 * @stability: Unstable
 * @include: libanjuta/interfaces/ianjuta-indenter.h
 *
 */

interface IAnjutaIndenter
{
  #include <libanjuta/interfaces/ianjuta-iterable.h>

	/**
	 * ianjuta_indenter_indent
	 * @obj: Self
	 * @start: Start of the area to indent
	 * @end: End of the area to indent
	 * @error: Error propagation
	 *
	 * Indent the area between @start and @end according to the indentation rules
	 * of the programming language. Usually implemented by language support plugins.
	 * Only one indenter can be loaded at a time.
	 * Note: Indenters always affect full lines, so start and end will be moved
	 * according to the next line start/end.
	 */
	 void indent (IAnjutaIterable* start, IAnjutaIterable* end);
}
