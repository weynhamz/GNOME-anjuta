Notes for Developers on contributing to Anjuta
----------------------------------------------

(TO BE EXPANDED OVER TIME - please post submissions to the Anjuta 
Development mailing list)


Tools
-----

IMPORTANT: please be careful about using Anjuta to develop Anjuta.
It is probably best not to use Anjuta for its own development,
as it may break lots of things while developing.

Anjuta is written using a mixture of C and C++.


Submitting patches
------------------

Small, self-contained patches are preferred - larger patches which
touch on a large number of areas of the source tree are more complex
to apply and test. Patches may be submitted to the project website, 
to the mailing lists, or directly to the project maintainer.

Unified diffs (diff -u) are preferred.


General source structure
------------------------

When editing the code, adding new classes or methods, etc. please 
conform with the style already followed in the source files.

Conventions:
* _cbs suffix - callbacks
* _gui suffix - UI definitions for windows, dialogs etc.

Key elements:
* src/ - the main Anjuta sources
* scintilla/ - the editor
* widgets/ - additional widgets used
* ccview/ - the C++ class viewer
* launcher/ - launcher wrapper used by the debugger
* tagmanager/ - the tagmanager library


Scintilla
---------

The editing component in Anjuta is Scintilla (www.scintilla.org). 
The Scintilla sources are imported to the scintilla/ directory in the
Anjuta source tree - some reorganisation is required:

Scintilla		Anjuta
---------		------
src/		->	scintilla/
gtk/		->	scintilla/
include/	->	scintilla/include

These are used to compile libscintilla.a, the library which provides
the bulk of Anjuta's editing functions.

The interface into Scintilla is in src/aneditor.cxx. This is based on
SciTE and a lot of care needs to be taken when merging code, since it
combines several different files from the SciTE source tree and is
quite flexible in the ways that they are used. Also, note that lexer
objects from Scintilla must be referenced in src/Makefile.am in order 
to get linked into Anjuta.


Documentation
-------------

The documentation is stored in the manuals/ directory, and consists 
of a set of SGML sources conforming to the GNOME Documentation Project's
Style Guide. Please ensure that all additions also follow these guidelines.

Screenshots used in the manual are processed using The Gimp. Single dialogs
and menus are converted to RGB and the Script-Fu Drop Shadow effect applied 
(with the default settings). All documentation images are in PNG format.

Translations of application messages are stored in the standard po/ 
directory structure at the top level of the source tree.


Graphics
--------

PNG format is preferred for application graphics.

The image filenames are mapped in the file src/pixmaps.h, with helper functions
for manipulating them in src/resources.c. Please use this method for including
graphics and do not use the filenames directly.



ARCHITECTURE:
-------------

FIXME.

1) Event Driven:
----------------

When Anjuta was first designed, the primary goal was to enable the use of 
external unix commnads in a more productive and intutive way. Therefore,
anjuta follows non-blocking input/output operations aggresively. This means
that anjuta UI will not freeze while it performs a lengthy task. All such
jobs are event-driven (I am not refering to the gtk-events here) and works
on asynchronous basis. The example jobs are compilation, debugging, file search,
class updates etc. While aynchronous event-driven implementation is more
complex than it's synchronous counter part, it gives a smooth and non-frustrative
operation. :-)

1.a) Executing external commands in non-blocking mode:
------------------------------------------------------

launcher (launcher.[c,h]) is the class responsible for executing external commands in
non-blocking mode. launcher_execute takes 4 arguments, first is the command
to be executed, second is the stdout callback, stderr callback and the child
terminated callback. They are called when there is chars available in the
stdout and stderr and when the child terminates respectively.

/* Start a job. */
/* command_str is the command to be executed */
/* stdout_func is the callback to be called when chars are received in STDOUT from the process */
/* stderr_func is the callback to be called when chars are received in STDERR from the process */
/* commnad_terminated is the callback to be called when the job is completed or terminated */
gboolean launcher_execute(gchar* command_str,
                               void (*stdout_func)(gchar*),
                               void (*stderr_func)(gchar*),
                               void (*command_terminated)(gint status, time_t time));

The three callbacks stated above should be of the following prototype:

/* The function names are arbitary */
void stdout_func (gchar * chars);
void stderr_func (gchar * chars);
void command_terminated (int return_status, time_t total_time);

Refer to the file launcher.h for further information.

Remember to use this launcher instead of gtk/glib non-blocking IO interface.

1.b) Process synchronization:
-----------------------------

The rest of the processes, which are quick (less that 1/10 sec) in execution
or whose IO interfaces are not necessary, can safely be forked just like a
normal fork. For shorter execution wait() system call would suffice it's
synchronization when the process ends, but for longer jobs, asynchronous
notification is suggested.

For asynchronos notification of child termination, a few additional steps
are needed to be done just after the fork() call. Register the child pid
with the call to anjuta_register_child(). It takes two arguments, first the
child pid and second, the callback to be called when the process with that
pid terminates. The call to the callback is shipped with the child exit status.

/* Registers the child for asynchronous notification */
void anjuta_register_child_process (pid_t pid,
			       void (*callback) (int status, gpointer user_data),
			       gpointer user_data);

/* Unregisters the child. No notification will be emited thereafter. */
void anjuta_unregister_child_process (pid_t pid);

The callback should be of the following prototype:

/* function name choosen arbitarily */
void child_terminated_callback (int status, gpointer user_data);

For further information, refer to the file anjuta.c.

WARNING: Do not hook up the signal SIGCHLD, for the similar purpose. Just use
the above method to perform the same thing. SIGCHLD is used by Anjuta 
internally to manage the children.

2) How to add new menu items in the Main Menu:
----------------------------------------------
FIXME.

2a) How to add new menu items in the Edit->Insert menu:
-------------------------------------------------------
There are 6 files which need to be updated.

* main_menubar_def.h - update inserttext1_submenu_uiinfo to add the item, help text 
and name of the callback function.
* main_menubar.h - update struct _EditSubMenu with the name of the menu widget
* main_menubar.c - update the array of items referenced around mb->edit.insert_*
* mainmenu_callbacks.h, mainmenu_callbacks.c - declare the name of the new callback 
function in the header file, and add the new function itself based on the
existing on_insert_*() functions
* controls.c - update the list of gtk_widget_set_sensitive calls with a new entry for 
the menu widget em->insert_* (as specified in main_menubar.h)


3) How to add new toolbar items in the Toolbars:
------------------------------------------------
FIXME.

4) Property/Config management:
------------------------------
Anjuta does not use gconf (at least, not now), and instead has its own config 
manager/properties manager. The source for this is in src/properties.cxx.
There are some advantages in using this over gconf, including the ability to
do variable substitution. Anjuta needs these advantages to operate properly.
Even though gconf have additional advantages, we are not really concerned about
them right now. In future, things may change, though.

FIXME.

When Anjuta was started, there were not many application support libraries.
To cope up with the requirements, anjuta had to implement the supports within
itself. And it is still going.

5) Global shortcut keys:
-----------------------

The following callback (located in anjuta.c) :

gint
on_anjuta_window_key_press_event (GtkWidget   *widget,
				  GdkEventKey *event,
				  gpointer     user_data)

is called when some key is pressed in the whole environnement, because the
event is triggered off by the main GtkWindow. It has been created for navigating
between the different buffers (Ctrl-[Shift]-Tab).

It's aim is to implement global shortcut keys. For now on, it only works in the main window.

Note : It's possible to install such an handler in the other windows if it's
really needed, so the new callback can propagate the event to app (the GnomeApp)
and we'll have a central place for those shortcuts.

How to add a global shortcut :
- - - - - - - - - - - - - - 

It's pretty self-explainatory, but here's the "howto" :

Just before the callback, you have some GDK modifiers "shortcuts", just because
it's a pain to write this each time, and the mxy make you see in an instant
which modifiers are used (Shift or Control) :

enum {
	m__ = 0,
	mS_ = GDK_SHIFT_MASK,
	m_C = GDK_CONTROL_MASK,
	mSC = GDK_SHIFT_MASK | GDK_SHIFT_MASK
};

These are to ease filling the structure (1) : 

You add an id for your shortcut in the enum : 

enum {
	ID_NEXTBUFFER = 0,
	ID_PREVBUFFER = 1
	...
};

Then, you add a line with the modifiers used, the GDK corresponding key, and the
shortcut id.

(1):

static ShortcutMapping global_keymap[] = {
	{ m_C, GDK_Tab,		 ID_NEXTBUFFER },
	{ mSC, GDK_ISO_Left_Tab, ID_PREVBUFFER },
	...
	{ 0,   0		 0 }
};

Finally, you add a case in the callback's switch :

gint
on_anjuta_window_key_press_event (GtkWidget   *widget,
	...

	switch (global_keymap[i].id) {
	case ID_xxx:
		<statements>

		break;
	}
	default:
		return FALSE;
	}

	...
